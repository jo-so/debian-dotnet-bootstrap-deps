<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NuGet.Build.Tasks.Pack</name>
  </assembly>
  <members>
    <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Build.MSBuildLogger">
      <summary>
            TaskLoggingHelper -&gt; ILogger
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.MSBuildTaskItem">
      <summary>
            TaskItem wrapper
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.IPackTaskLogic">
      <summary>
            The logic for converting the set of pack MSBuild task parameters to a fully initialized package builder. The
            set of parameters provided to the MSBuild pask task is <see cref="T:NuGet.Build.Tasks.Pack.IPackTaskRequest`1" />. This interface
            allows the logic of the pack task to be seperated from the MSBuild-specific types. The motivation is
            testability.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackArgs(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})">
      <summary>
            Initialize the pack args from the pack task request.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackageBuilder(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})">
      <summary>
            Initialize the package builder from the pack task request.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackCommandRunner(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem},NuGet.Commands.PackArgs,NuGet.Packaging.PackageBuilder)">
      <summary>
            Initialize the pack command runner from the pack task request and the output of
            <see cref="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackArgs(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})" /> and
            <see cref="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackageBuilder(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})" />.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.BuildPackage(NuGet.Commands.PackCommandRunner)">
      <summary>
            Build the package. This method actually writes the .nupkg to disk.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.IPackTaskRequest`1">
      <summary>
            All of the properties provided by MSBuild to execute pack.
            </summary>
      <typeparam name="TItem">
            The item type. This will either be <see cref="T:Microsoft.Build.Framework.ITaskItem" /> or a <see cref="T:NuGet.Commands.IMSBuildItem" />.
            </typeparam>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.PackTask.GetRequest">
      <summary>
            This method does two important things:
            1. Normalizes string parameters, trimming whitespace and coalescing empty strings to null.
            2. Wrap <see cref="T:Microsoft.Build.Framework.ITaskItem" /> instances to facility unit testing.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.PackTask.PackTaskLogic">
      <summary>
            This property is only used for testing.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.AssetsFileDoesNotHaveValidPackageSpec">
      <summary>
              Looks up a localized string similar to The assets file found does not contain a valid package spec. Try restoring the project again. The location of the assets file is {0}..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.AssetsFileNotFound">
      <summary>
              Looks up a localized string similar to The assets file produced by restore does not exist. Try restoring the project again. The expected location of the assets file is {0}..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.Error_FileNotFound">
      <summary>
              Looks up a localized string similar to The file '{0}' to be packed was not found on disk..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidMinClientVersion">
      <summary>
              Looks up a localized string similar to MinClientVersion string specified '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidNuspecProperties">
      <summary>
              Looks up a localized string similar to NuspecProperties should be in the form of "key1=value1;key2=value2"..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidPackageReferenceVersion">
      <summary>
              Looks up a localized string similar to PackageReference {0} needs to have a valid version..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidPackageVersion">
      <summary>
              Looks up a localized string similar to PackageVersion string specified '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Invalid target framework for the file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.NoPackItemProvided">
      <summary>
              Looks up a localized string similar to No project was provided to the PackTask..
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IDirectoryContents">
      <summary>
            Represents a directory's content in the file provider.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IDirectoryContents.Exists">
      <summary>
            True if a directory was located at the given path.
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IFileInfo">
      <summary>
            Represents a file in the given file provider.
            </summary>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileInfo.CreateReadStream">
      <summary>
            Return file contents as readonly stream. Caller should dispose stream when complete.
            </summary>
      <returns>The file stream</returns>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Exists">
      <summary>
            True if resource exists in the underlying storage system.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Length">
      <summary>
            The length of the file in bytes, or -1 for a directory or non-existing files.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.PhysicalPath">
      <summary>
            The path to the file, including the file name. Return null if the file is not directly accessible.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Name">
      <summary>
            The name of the file or directory, not including any path.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.LastModified">
      <summary>
            When the file was last modified
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.IsDirectory">
      <summary>
            True for the case TryGetDirectoryContents has enumerated a sub-directory
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IFileProvider">
      <summary>
            A read-only file provider abstraction.
            </summary>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.GetFileInfo(System.String)">
      <summary>
            Locate a file at the given path.
            </summary>
      <param name="subpath">Relative path that identifies the file.</param>
      <returns>The file information. Caller must check Exists property.</returns>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.GetDirectoryContents(System.String)">
      <summary>
            Enumerate a directory at the given path, if any.
            </summary>
      <param name="subpath">Relative path that identifies the directory.</param>
      <returns>Returns the contents of the directory.</returns>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.Watch(System.String)">
      <summary>
            Creates a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken" /> for the specified <paramref name="filter" />.
            </summary>
      <param name="filter">Filter string used to determine what files or folders to monitor. Example: **/*.cs, *.*, subFolder/**/*.cshtml.</param>
      <returns>An <see cref="T:Microsoft.Extensions.Primitives.IChangeToken" /> that is notified when a file matching <paramref name="filter" /> is added, modified or deleted.</returns>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.NotFoundFileInfo">
      <summary>
            Represents a non-existing file.
            </summary>
    </member>
    <member name="T:Microsoft.Extensions.Primitives.IChangeToken">
      <summary>
            Propagates notifications that a change has occured.
            </summary>
    </member>
    <member name="M:Microsoft.Extensions.Primitives.IChangeToken.RegisterChangeCallback(System.Action{System.Object},System.Object)">
      <summary>
            Registers for a callback that will be invoked when the entry has changed.
            <see cref="P:Microsoft.Extensions.Primitives.IChangeToken.HasChanged" /> MUST be set before the callback is invoked.
            </summary>
      <param name="callback">The <see cref="!:Action&lt;object&gt;" /> to invoke.</param>
      <param name="state">State to be passed into the callback.</param>
      <returns>An <see cref="T:System.IDisposable" /> that is used to unregister the callback.</returns>
    </member>
    <member name="P:Microsoft.Extensions.Primitives.IChangeToken.HasChanged">
      <summary>
            Gets a value that indicates if a change has occured.
            </summary>
    </member>
    <member name="P:Microsoft.Extensions.Primitives.IChangeToken.ActiveChangeCallbacks">
      <summary>
            Indicates if this token will pro-actively raise callbacks. Callbacks are still guaranteed to fire, eventually.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands304385.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands304385.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Commands304385.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands304385.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Commands.DeleteRunner">
      <summary>
            Shared code to run the "delete" command from the command line projects
            </summary>
    </member>
    <member name="T:NuGet.Commands.LocalsCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget locals command
            </summary>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ExecuteCommand(NuGet.Commands.LocalsArgs)">
      <summary>
            Executes the logic for nuget locals command.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ListLocalResource(NuGet.Commands.LocalsCommandRunner.LocalResourceName,NuGet.Commands.LocalsArgs)">
      <summary>
            Lists out the cache location(s) path.
            </summary>
      <param name="localResourceName">Cache resource to be listed</param>
      <throws>Thorws <code>ArgumentException</code> if the specified resource name does not match a known cache type.</throws>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.PrintLocalResourcePath(System.String,System.String,NuGet.Commands.LocalsArgs)">
      <summary>
            Prints the specified local resource path.
            </summary>
      <param name="resourceName"> Specified resource name</param>
      <param name="path"> Path for the specified resource</param>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearLocalResource(NuGet.Commands.LocalsCommandRunner.LocalResourceName,NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the specified cache location(s).
            </summary>
      <param name="localResourceName">
      </param>
      <throws>Thorws <code>ArgumentException</code> if the specified resource name does not match a known cache type.</throws>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetGlobalPackagesFolder(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the global NuGet packages cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetHttpCache(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the NuGet v3 HTTP cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetTempFolder(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the temp folder cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.GetLocalResourceName(System.String)">
      <summary>
            Identifies the specified resource name to be cleared.
            </summary>
      <param name="localResourceName">specified resource name</param>
      <returns>Returns <code>LocalResourceName</code> indicating the local resource name specified.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearCacheDirectory(System.String,NuGet.Commands.LocalsArgs)">
      <summary>
            Recursively deletes the specified directory tree.
            </summary>
      <param name="folderPath">Specified directory to be deleted</param>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="T:NuGet.Commands.PushRunner">
      <summary>
            Shared code to run the "push" command from the command line projects
            </summary>
    </member>
    <member name="T:NuGet.Commands.ListCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget list command
            </summary>
    </member>
    <member name="M:NuGet.Commands.ListCommandRunner.ExecuteCommand(NuGet.Commands.ListArgs)">
      <summary>
            Executes the logic for nuget list command.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.FinalOutputPath">
      <summary>
            This is the final output path of the assembly on disk as set by msbuild.
            </summary>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.TargetPath">
      <summary>
            This denotes the TargetPath as set by msbuild. Usually this is just the file name, but for satellite DLLs,
            this is Culture\filename.
             </summary>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.TargetFramework">
      <summary>
            This is the target framework for which this assembly was built.
            </summary>
    </member>
    <member name="M:NuGet.Commands.CompatibilityIssue.FormatMessage(System.String,System.String,System.String)">
      <summary>
            Build a incompatible error message for either a package or project
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.GetContentGroupsForFramework(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.ContentModel.ContentItemGroup})">
      <summary>
            Get all content groups that have the nearest TxM
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.GetContentFileGroup(NuGet.Frameworks.NuGetFramework,NuGet.Packaging.NuspecReader,System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup})">
      <summary>
            Apply build actions from the nuspec to items from the contentFiles folder.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.CreateEmptyItem">
      <summary>
            Create an empty lock file item for any/any
            </summary>
    </member>
    <member name="T:NuGet.Commands.VirtualFileProvider">
      <summary>
            A virtual file system based on a list of strings from ContentModel.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.LockFilePath">
      <summary>
            Gets the path that the lock file will be written to.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.LockFile">
      <summary>
            Gets the lock file that was generated during the restore or, in the case of a locked lock file,
            was used to determine the packages to install during the restore.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.PreviousLockFile">
      <summary>
            The existing lock file. This is null if no lock file was provided on the <see cref="T:NuGet.Commands.RestoreRequest" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.MSBuildOutputFiles">
      <summary>
            Props and targets files to be written to disk.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileBuilder.IsAllowedLibraryFile(System.String)">
      <summary>
            True if the file should be added to the lock file library
            Fale if it is an OPC file or empty directory
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildOutputFile.Path">
      <summary>
            Output path on disk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildOutputFile.Content">
      <summary>
            MSBuild file content. This will be null for files
            that should be removed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Position">
      <summary>
            Optional position arguement used when ordering groups in the output file.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Conditions">
      <summary>
            Conditions applied to the item group. These will be AND'd together.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Items">
      <summary>
            Items or imports.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.RootName">
      <summary>
            Root element name.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Condition">
      <summary>
            Combined conditions
            </summary>
    </member>
    <member name="T:NuGet.Commands.DependencyGraphSpecRequestProvider">
      <summary>
            In Memory dg file provider.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DependencyGraphSpecRequestProvider.CollectReferences(NuGet.ProjectModel.ExternalProjectReference,System.Collections.Generic.Dictionary{System.String,NuGet.ProjectModel.ExternalProjectReference},System.Collections.Generic.HashSet{NuGet.ProjectModel.ExternalProjectReference})">
      <summary>
            Return all references for a given project path.
            References is modified by this method.
            This includes the root project.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IMSBuildItem">
      <summary>
            ITaskItem abstraction
            </summary>
    </member>
    <member name="M:NuGet.Commands.IMSBuildItem.GetProperty(System.String)">
      <summary>
            Retrieve property value and trim.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IMSBuildItem.GetProperty(System.String,System.Boolean)">
      <summary>
            Retrieve property value with optional trimming.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IMSBuildItem.Identity">
      <summary>
            Include attribute value.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IMSBuildItem.Properties">
      <summary>
            Raw untrimmed properties.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IPreLoadedRestoreRequestProvider">
      <summary>
            Retrieves pre-loaded restore requests. The inputs here have already been determined.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IPreLoadedRestoreRequestProvider.CreateRequests(NuGet.Commands.RestoreArgs)">
      <summary>
            Create RestoreRequest objects.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IRestoreRequestProvider.Supports(System.String)">
      <summary>
            True if this provider supports the given path. Only one provider should handle an input.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IRestoreRequestProvider.CreateRequests(System.String,NuGet.Commands.RestoreArgs)">
      <summary>
            Create RestoreRequest objects.
            </summary>
      <param name="inputPath">Project.json or project file path.</param>
      <param name="restoreContext">Command line arguments.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Commands.MSBuildItem">
      <summary>
            Internal ITaskItem abstraction
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildItem.GetProperty(System.String)">
      <summary>
            Get property or null if empty. Trims whitespace from values.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildItem.GetProperty(System.String,System.Boolean)">
      <summary>
            Get property or null if empty.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreArgs.GetEffectiveSources(NuGet.Configuration.ISettings)">
      <summary>
            Uses either Sources or Settings, and then adds Fallback sources.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreArgs.SourceRepositories">
      <summary>
            Sources to use for restore. Overrides Sources
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreArgs.Sources">
      <summary>
            Sources to use for restore. This is not used if SourceRepositories contains the 
            already built SourceRepository objects.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreSpecException">
      <summary>
            DG v2 related validation error.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreCommandProviders">
      <summary>
            Feed providers
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommandProviders.#ctor(NuGet.Repositories.NuGetv3LocalRepository,System.Collections.Generic.IReadOnlyList{NuGet.Repositories.NuGetv3LocalRepository},System.Collections.Generic.IReadOnlyList{NuGet.DependencyResolver.IRemoteDependencyProvider},System.Collections.Generic.IReadOnlyList{NuGet.DependencyResolver.IRemoteDependencyProvider})">
      <summary>
            Providers used by the restore command. These can be shared across restores.
            </summary>
      <param name="globalPackages">Path to the global packages folder.</param>
      <param name="fallbackPackageFolders">Path to any fallback package folders.</param>
      <param name="localProviders">This is typically just a provider for the global packages folder.</param>
      <param name="remoteProviders">All dependency providers.</param>
    </member>
    <member name="P:NuGet.Commands.RestoreCommandProviders.GlobalPackages">
      <summary>
            A <see cref="T:NuGet.Repositories.NuGetv3LocalRepository" /> repository may be passed in as part of the request.
            This allows multiple restores to share the same cache for the global packages folder
            and reduce disk hits.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreCommandProvidersCache">
      <summary>
            Caches providers for the RestoreCommand. This helper ensures that no resources are duplicated.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.Project">
      <summary>
            The project to perform the restore on
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.PackagesDirectory">
      <summary>
            The directory in which to install packages
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.IsLowercasePackagesDirectory">
      <summary>
            Whether or not packages written and read from the global packages directory has
            lowercase ID and version folder names or original case.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ExternalProjects">
      <summary>
            A list of projects provided by external build systems (i.e. MSBuild)
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.LockFilePath">
      <summary>
            The path to the lock file to read/write. If not specified, uses the file 'project.lock.json' in the same
            directory as the provided PackageSpec.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ExistingLockFile">
      <summary>
            The existing lock file to use. If not specified, the lock file will be read from the <see cref="P:NuGet.Commands.RestoreRequest.LockFilePath" />
            (or, if that property is not specified, from the default location of the lock file, as specified in the
            description for <see cref="P:NuGet.Commands.RestoreRequest.LockFilePath" />)
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.MaxDegreeOfConcurrency">
      <summary>
            The number of concurrent tasks to run during installs. Defaults to
            <see cref="F:NuGet.Commands.RestoreRequest.DefaultDegreeOfConcurrency" />. Set this to '1' to
            run without concurrency.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.CompatibilityProfiles">
      <summary>
            Additional compatibility profiles to check compatibility with.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.LockFileVersion">
      <summary>
            Lock file version format to output.
            </summary>
      <remarks>This defaults to the latest version.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.RequestedRuntimes">
      <summary>
            These Runtime Ids will be added to the graph in addition to the runtimes contained
            in project.json under runtimes.
            </summary>
      <remarks>RIDs are case sensitive.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.PackageSaveMode">
      <summary>
            Gets or sets the <see cref="T:NuGet.Packaging.PackageSaveMode" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.FallbackRuntimes">
      <summary>
            These Runtime Ids will be used if <see cref="P:NuGet.Commands.RestoreRequest.RequestedRuntimes" /> and the project runtimes
            are both empty.
            </summary>
      <remarks>RIDs are case sensitive.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.DependencyProviders">
      <summary>
            This contains resources that are shared between project restores.
            This includes both remote and local package providers.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ProjectStyle">
      <summary>
            Defines the paths and behavior for outputs
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.RestoreOutputPath">
      <summary>
            Restore output path
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ValidateRuntimeAssets">
      <summary>
            Compatibility options
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.GetAllInstalled">
      <summary>
            Calculates the complete set of all packages installed by this operation
            </summary>
      <remarks>
            This requires quite a bit of iterating over the graph so the result should be cached
            </remarks>
      <returns>A set of libraries that were installed by this operation</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.GetAllUnresolved">
      <summary>
            Calculates the complete set of all unresolved dependencies for this operation
            </summary>
      <remarks>
            This requires quite a bit of iterating over the graph so the result should be cached
            </remarks>
      <returns>A set of dependencies that were unable to be resolved by this operation</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.CommitAsync(NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Commits the lock file contained in <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> and the MSBuild targets/props to
            the local file system.
            </summary>
      <remarks>If <see cref="P:NuGet.Commands.RestoreResult.PreviousLockFile" /> and <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> are identical
             the file will not be written to disk.</remarks>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.CommitAsync(NuGet.Common.ILogger,System.Boolean,System.Threading.CancellationToken)">
      <summary>
            Commits the lock file contained in <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> and the MSBuild targets/props to
            the local file system.
            </summary>
      <remarks>If <see cref="P:NuGet.Commands.RestoreResult.PreviousLockFile" /> and <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> are identical
             the file will not be written to disk.</remarks>
      <param name="forceWrite">Write out the lock file even if no changes exist.</param>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.LockFilePath">
      <summary>
            Gets the path that the lock file will be written to.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.RestoreGraphs">
      <summary>
            Gets the resolved dependency graphs produced by the restore operation
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.MSBuildOutputFiles">
      <summary>
            Props and targets files to be written to disk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.ProjectStyle">
      <summary>
            Restore type.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.LockFile">
      <summary>
            Gets the lock file that was generated during the restore or, in the case of a locked lock file,
            was used to determine the packages to install during the restore.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.PreviousLockFile">
      <summary>
            The existing lock file. This is null if no lock file was provided on the <see cref="T:NuGet.Commands.RestoreRequest" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.ElapsedTime">
      <summary>
            Restore time
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreRunner">
      <summary>
            Shared code to run the "restore" command for dotnet restore, nuget.exe, and VS.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunAsync(NuGet.Commands.RestoreArgs,System.Threading.CancellationToken)">
      <summary>
            Create requests, execute requests, and commit restore results.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.Run(NuGet.Commands.RestoreArgs)">
      <summary>
            Create requests, execute requests, and commit restore results.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest},NuGet.Commands.RestoreArgs,System.Threading.CancellationToken)">
      <summary>
            Execute and commit restore requests.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunWithoutCommit(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest},NuGet.Commands.RestoreArgs)">
      <summary>
            Execute and commit restore requests.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.GetRequests(NuGet.Commands.RestoreArgs)">
      <summary>
            Create restore requests but do not execute them.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreSummaryRequest">
      <summary>
            Wrapper for RestoreRequest
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.RuntimeIdentifier">
      <summary>
            Gets the runtime identifier used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Framework">
      <summary>
            Gets the <see cref="T:NuGet.Frameworks.NuGetFramework" /> used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Conventions">
      <summary>
            Gets the <see cref="T:NuGet.Client.ManagedCodeConventions" /> used to resolve assets from packages in this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.RuntimeGraph">
      <summary>
            Gets the <see cref="P:NuGet.Commands.RestoreTargetGraph.RuntimeGraph" /> that defines runtimes and their relationships for this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Graphs">
      <summary>
            Gets the resolved dependency graph
            </summary>
    </member>
    <member name="F:NuGet.Commands.BuildAssetsUtils.MacroCandidates">
      <summary>
            The macros that we may use in MSBuild to replace path roots.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.WriteFiles(System.Collections.Generic.IEnumerable{NuGet.Commands.MSBuildOutputFile},NuGet.Common.ILogger)">
      <summary>
            Write XML to disk.
            Delete files which do not have new XML.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateMultiTargetFailureFiles(System.String,System.String,NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Create MSBuild targets and props files.
            Null will be returned for files that should be removed.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.AddNuGetPropertiesToFirstImport(System.Collections.Generic.IEnumerable{NuGet.Commands.MSBuildOutputFile},System.Collections.Generic.IEnumerable{System.String},System.String,NuGet.ProjectModel.ProjectStyle,System.String,System.Boolean)">
      <summary>
            Add standard properties to only props file if it exists, otherwise the targets.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.AddNuGetProperties(System.Xml.Linq.XDocument,System.Collections.Generic.IEnumerable{System.String},System.String,NuGet.ProjectModel.ProjectStyle,System.String,System.Boolean)">
      <summary>
            Apply standard properties in a property group.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateEmptyImportsFile">
      <summary>
            Get empty file with the base properties.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateMSBuildFile(System.Collections.Generic.List{NuGet.Commands.MSBuildRestoreItemGroup},NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Returns null if the result should not exist on disk.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.HasChanges(System.Xml.Linq.XDocument,System.String,NuGet.Common.ILogger)">
      <summary>
            Check if the file has changes compared to the original on disk.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IncludeFlagUtils.DependencyNode">
      <summary>
            A simple node class to hold the incoming dependency edge during the graph walk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IncludeFlagUtils.DependencyNode.DependencyType">
      <summary>
            Incoming edge
            </summary>
    </member>
    <member name="P:NuGet.Commands.IncludeFlagUtils.DependencyNode.Item">
      <summary>
            Node item
            </summary>
    </member>
    <member name="M:NuGet.Commands.IncludeFlagUtils.GetDependencyType(NuGet.DependencyResolver.GraphNode{NuGet.DependencyResolver.RemoteResolveResult},NuGet.DependencyResolver.GraphNode{NuGet.DependencyResolver.RemoteResolveResult})">
      <summary>
            Find the flags for a node. 
            Include - Exclude - ParentExclude
            </summary>
    </member>
    <member name="M:NuGet.Commands.IncludeFlagUtils.OrderType(NuGet.DependencyResolver.GraphItem{NuGet.DependencyResolver.RemoteResolveResult})">
      <summary>
            Prefer projects over packages
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.CreateLockFileTargetProject(NuGet.DependencyResolver.GraphItem{NuGet.DependencyResolver.RemoteResolveResult},NuGet.LibraryModel.LibraryIdentity,NuGet.LibraryModel.LibraryIncludeFlags,NuGet.Commands.RestoreTargetGraph,NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Create a library for a project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ConvertToProjectPaths(System.Collections.Generic.Dictionary{System.String,NuGet.ProjectModel.ProjectRestoreMetadataFile},System.String,System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem})">
      <summary>
            Convert from the expected nupkg path to the on disk path.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetLockFileItems(System.Collections.Generic.IReadOnlyList{NuGet.ContentModel.SelectionCriteria},NuGet.ContentModel.ContentItemCollection,NuGet.ContentModel.PatternSet[])">
      <summary>
            Create lock file items for the best matching group.
            </summary>
      <remarks>Enumerate this once after calling.</remarks>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetBuildItemsForPackageId(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem},System.String)">
      <summary>
            Get packageId.targets and packageId.props
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.CreateCriteria(NuGet.Commands.RestoreTargetGraph,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Creates an ordered list of selection criteria to use. This supports fallback frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ClearIfExists``1(System.Collections.Generic.IList{``0})">
      <summary>
            Clears a lock file group and replaces the first item with _._ if 
            the group has items. Empty groups are left alone.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GroupHasNonEmptyItems(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem})">
      <summary>
            True if the group has items that do not end with _._
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetContentGroupsForFramework(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup},System.String)">
      <summary>
            Group all items by the primary key, then select the nearest TxM 
            within each group.
            Items that do not contain the primaryKey will be filtered out.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetRuntimeTargetItems(System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup},System.String)">
      <summary>
            Create LockFileItems from groups of library items.
            </summary>
      <param name="groups">Library items grouped by RID.</param>
      <param name="assetType">Lock file section the items apply to.</param>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ToDirectorySeparator(System.String)">
      <summary>
            Replace / with the local directory separator if needed.
            For OSX and Linux the same string is returned.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ExcludeItems(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Replace excluded asset groups with _._ if they have &gt; 0 items.
            </summary>
    </member>
    <member name="T:NuGet.Commands.MSBuildRestoreUtility">
      <summary>
            Helpers for dealing with dg files and processing msbuild related inputs.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetDependencySpec(System.Collections.Generic.IEnumerable{NuGet.Commands.IMSBuildItem})">
      <summary>
            Convert MSBuild items to a DependencyGraphSpec.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.LibraryModel.LibraryDependency,System.String,System.String,System.String)">
      <summary>
            Insert asset flags into dependency, based on ;-delimited string args
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.ProjectModel.ProjectRestoreReference,System.String,System.String,System.String)">
      <summary>
            Insert asset flags into project dependency, based on ;-delimited string args
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetPackageSpec(System.Collections.Generic.IEnumerable{NuGet.Commands.IMSBuildItem})">
      <summary>
            Convert MSBuild items to a PackageSpec.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetVersion(NuGet.Commands.IMSBuildItem)">
      <summary>
            Return the parsed version or 1.0.0 if the property does not exist.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.PersistDGFileIfDebugging(NuGet.ProjectModel.DependencyGraphSpec,NuGet.Common.ILogger)">
      <summary>
            Write the dg file to a temp location if NUGET_PERSIST_DG.
            </summary>
      <remarks>This is a noop if NUGET_PERSIST_DG is not set to true.</remarks>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.IsPersistDGSet">
      <summary>
            True if NUGET_PERSIST_DG is set to true.
            </summary>
    </member>
    <member name="M:NuGet.Commands.SpecValidationUtility.ValidateDependencySpec(NuGet.ProjectModel.DependencyGraphSpec)">
      <summary>
            Validate a dg file. This will throw a RestoreSpecException if there are errors.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetSpec(System.String,System.String,NuGet.Versioning.VersionRange,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Build a package spec in memory to execute the tool restore as if it were
            its own project. For now, we always restore for a null runtime and a single
            constant framework.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetSubSetRequests(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest})">
      <summary>
            Only one output can win per packages folder/version range. Between colliding requests take
            the intersection of the inputs used.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetToolIdOrNullFromSpec(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Returns the name of the single dependency in the spec or null.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetToolDependencyOrNullFromSpec(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Returns the name of the single dependency in the spec or null.
            </summary>
    </member>
    <member name="T:NuGet.Commands.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.AddFileToPackage">
      <summary>
              Looks up a localized string similar to Add file '{0}' to package as '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.BuildingProjectTargetingFramework">
      <summary>
              Looks up a localized string similar to Building project '{0}' for target framework '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_BuildFailed">
      <summary>
              Looks up a localized string similar to Failed to build using '{0} {1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_CannotFindMsbuild">
      <summary>
              Looks up a localized string similar to Cannot find version of msbuild..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInput">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. The file type was not recognized..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInputConfig">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. Valid file names are 'packages.config' or 'packages.*.config'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInputJson">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. Valid file names are 'project.json' or '*.project.json'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Failed to build package because of an unsupported targetFramework value on '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_MissingSourceParameter">
      <summary>
              Looks up a localized string similar to Source parameter was not specified..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackageCommandNoFilesForLibPackage">
      <summary>
              Looks up a localized string similar to Failed to build package. Ensure '{0}' includes assembly files. For help on building symbols package, visit {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackageCommandNoFilesForSymbolsPackage">
      <summary>
              Looks up a localized string similar to Failed to build package. Ensure '{0}' includes source and symbol files. For help on building symbols package, visit {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackFailed">
      <summary>
              Looks up a localized string similar to Failed to build package. {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_ProcessingNuspecFile">
      <summary>
              Looks up a localized string similar to Error occurred when processing file '{0}': {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateBuildOutput">
      <summary>
              Looks up a localized string similar to No build found in {0}. Use the -Build option or build the project..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateRestoreTarget">
      <summary>
              Looks up a localized string similar to The folder '{0}' does not contain a project to restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateRestoreTarget_Because">
      <summary>
              Looks up a localized string similar to Failed to find a project to restore in the folder '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnknownBuildAction">
      <summary>
              Looks up a localized string similar to Package '{0}' specifies an invalid build action '{1}' for file '{2}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_XPROJNotAllowed">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. XProj support has been removed. Support for XProj and standalone project.json files has been removed, to continue working with legacy projects use NuGet 3.5.x from https://nuget.org/downloads.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FailedToBuildProject">
      <summary>
              Looks up a localized string similar to Failed to build '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FileNotAddedToPackage">
      <summary>
              Looks up a localized string similar to File '{0}' is not added because the package already contains file '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InputFileNotSpecified">
      <summary>
              Looks up a localized string similar to Please specify a nuspec, project.json, or project file to use.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidRestoreInput">
      <summary>
              Looks up a localized string similar to Invalid restore input. {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidRestoreInputWithFiles">
      <summary>
              Looks up a localized string similar to Invalid restore input. {0} Input files: {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidSource">
      <summary>
              Looks up a localized string similar to The specified source '{0}' is invalid. Please provide a valid source..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearedSuccessful">
      <summary>
              Looks up a localized string similar to Local resources cleared..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearFailed">
      <summary>
              Looks up a localized string similar to Clearing local resources failed: Unable to delete one or more files..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetGlobalPackagesCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet global packages cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetHttpCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet HTTP cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetTempCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet Temp cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_FailedToDeletePath">
      <summary>
              Looks up a localized string similar to Failed to delete '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_Help">
      <summary>
               Looks up a localized string similar to usage: NuGet locals &lt;all | http-cache | global-packages | temp&gt; [--clear | -c | --list | -l]
            For more information, visit http://docs.nuget.org/docs/reference/command-line-reference.
             </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_InvalidLocalResourceName">
      <summary>
              Looks up a localized string similar to An invalid local resource name was provided. Please provide one of the following values: http-cache, temp, global-packages, all..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_LocalResourcePathNotSet">
      <summary>
              Looks up a localized string similar to The location of local resource '{0}' is undefined..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_LocalsPartiallyCleared">
      <summary>
              Looks up a localized string similar to Local resources partially cleared..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CheckingCompatibility">
      <summary>
              Looks up a localized string similar to Checking compatibility of packages on {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CheckingPackageCompatibility">
      <summary>
              Looks up a localized string similar to Checking compatibility for {0} {1} with {2}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_Committing">
      <summary>
              Looks up a localized string similar to Committing restore....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ConfigFileSummary">
      <summary>
              Looks up a localized string similar to NuGet Config files used:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ConvertedPackageToOriginalCase">
      <summary>
              Looks up a localized string similar to The package {0} was converted to original case in the packages directory..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CycleDetected">
      <summary>
              Looks up a localized string similar to Cycle detected:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_DependencyBumpedUp">
      <summary>
              Looks up a localized string similar to Dependency specified was {0} {1} but ended up with {2} {3}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_DowngradeWarning">
      <summary>
              Looks up a localized string similar to Detected package downgrade: {0} from {1} to {2}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ErrorSummary">
      <summary>
              Looks up a localized string similar to Errors in {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FailedToResolveConflicts">
      <summary>
              Looks up a localized string similar to Failed to resolve conflicts for {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FeedsUsedSummary">
      <summary>
              Looks up a localized string similar to Feeds used:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FoundProjectRoot">
      <summary>
              Looks up a localized string similar to Found project root directory: {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FrameworkDisplay">
      <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FrameworkRIDDisplay">
      <summary>
              Looks up a localized string similar to {0} ({1}) / {2}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_GeneratingMsBuildFile">
      <summary>
              Looks up a localized string similar to Generating MSBuild file {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ImportsFallbackWarning">
      <summary>
              Looks up a localized string similar to Package '{0}' was restored using '{1}' instead the project target framework '{2}'. This may cause compatibility problems..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstalledSummary">
      <summary>
              Looks up a localized string similar to Installed:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstalledSummaryCount">
      <summary>
              Looks up a localized string similar to {0} package(s) to {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstallingPackage">
      <summary>
              Looks up a localized string similar to Installing {0} {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_LoadedProject">
      <summary>
              Looks up a localized string similar to Loaded project {0} from {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_LockFileMissingLibraryForTargetLibrary">
      <summary>
              Looks up a localized string similar to {0} {1} is specified in the Lock File target for {2} but is not present in the top-level Libraries list..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_LockFileOutOfDate">
      <summary>
              Looks up a localized string similar to The lock file is out-of-date relative to the project file. Regenerating the lock file and re-locking..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MergingRuntimes">
      <summary>
              Looks up a localized string similar to Merging in runtimes defined in {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MissingImplementationFx">
      <summary>
              Looks up a localized string similar to {0} {1} provides a compile-time reference assembly for {2} on {3}, but there is no compatible run-time assembly..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MissingImplementationFxRuntime">
      <summary>
              Looks up a localized string similar to {0} {1} provides a compile-time reference assembly for {2} on {3}, but there is no run-time assembly compatible with {4}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandAddedFile">
      <summary>
              Looks up a localized string similar to Added file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandAttemptingToBuildSymbolsPackage">
      <summary>
              Looks up a localized string similar to Attempting to build symbols package for '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandSuccess">
      <summary>
              Looks up a localized string similar to Successfully created package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx">
      <summary>
              Looks up a localized string similar to Package {0} {1} is not compatible with {2}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx_NoSupports">
      <summary>
              Looks up a localized string similar to Package {0} {1} does not support any target frameworks..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx_Supports">
      <summary>
              Looks up a localized string similar to Package {0} {1} supports:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackagesAndProjectsAreCompatible">
      <summary>
              Looks up a localized string similar to All packages and projects are compatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackagesIncompatible">
      <summary>
              Looks up a localized string similar to One or more packages are incompatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectDoesNotSpecifyTargetFrameworks">
      <summary>
              Looks up a localized string similar to The project {0} does not specify any target frameworks in {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx">
      <summary>
              Looks up a localized string similar to Project {0} is not compatible with {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx_NoSupports">
      <summary>
              Looks up a localized string similar to Project {0} does not support any target frameworks..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx_Supports">
      <summary>
              Looks up a localized string similar to Project {0} supports:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectsIncompatible">
      <summary>
              Looks up a localized string similar to One or more projects are incompatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ReadingProject">
      <summary>
              Looks up a localized string similar to Reading project file {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ResolverConflict">
      <summary>
              Looks up a localized string similar to Unable to satisfy conflicting requests for '{0}': {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ResolvingConflicts">
      <summary>
              Looks up a localized string similar to Resolving conflicts for {0}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreComplete">
      <summary>
              Looks up a localized string similar to Restore completed in {0} for {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreFailed">
      <summary>
              Looks up a localized string similar to Restore failed in {0} for {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringPackages">
      <summary>
              Looks up a localized string similar to Restoring packages for {0}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringPackagesForCompat">
      <summary>
              Looks up a localized string similar to Restoring packages for {0} to determine compatibility....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringToolPackages">
      <summary>
              Looks up a localized string similar to Restoring packages for tool '{0}' in {1}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RunningNonParallelRestore">
      <summary>
              Looks up a localized string similar to Running non-parallel restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RunningParallelRestore">
      <summary>
              Looks up a localized string similar to Running restore with {0} concurrent jobs..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ScanningForRuntimeJson">
      <summary>
              Looks up a localized string similar to Scanning packages for runtime.json files....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_SkippingRuntimeWalk">
      <summary>
              Looks up a localized string similar to Skipping runtime dependency walk, no runtimes defined in project.json..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UnknownCompatibilityProfile">
      <summary>
              Looks up a localized string similar to Unknown Compatibility Profile: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UnresolvedDependency">
      <summary>
              Looks up a localized string similar to Unable to resolve '{0}' for '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UsingPackagesDirectory">
      <summary>
              Looks up a localized string similar to Using packages directory: {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UsingSource">
      <summary>
              Looks up a localized string similar to Using source {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_VersionConflict">
      <summary>
              Looks up a localized string similar to Version conflict detected for {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MissingRequiredProperty">
      <summary>
              Looks up a localized string similar to Missing required property '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MissingRequiredPropertyForProjectType">
      <summary>
              Looks up a localized string similar to Missing required property '{0}' for project type '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MSBuildWarning_MultiTarget">
      <summary>
              Looks up a localized string similar to Packages containing MSBuild targets and props files cannot be fully installed in projects targeting multiple frameworks. The MSBuild targets and props files have been ignored..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.NuGetDocs">
      <summary>
              Looks up a localized string similar to http://docs.nuget.org/.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackageCommandFileFromDependencyIsChanged">
      <summary>
              Looks up a localized string similar to File from dependency is not changed. File '{0}' is not added..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackageCommandFileFromDependencyIsNotChanged">
      <summary>
              Looks up a localized string similar to File from dependency is not changed. File '{0}' is not added..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackagingFilesFromOutputPath">
      <summary>
              Looks up a localized string similar to Packing files from '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PersistDGFile">
      <summary>
              Looks up a localized string similar to Persisting restore input to '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PropertyNotAllowed">
      <summary>
              Looks up a localized string similar to Invalid input combination. Property '{0}' is not allowed..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PropertyNotAllowedForProjectType">
      <summary>
              Looks up a localized string similar to Invalid input combination. Property '{0}' is not allowed for project type '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.ResolverRequest_ToStringFormat">
      <summary>
              Looks up a localized string similar to {0} (via {1}).
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationDuplicateFrameworks">
      <summary>
              Looks up a localized string similar to Duplicate frameworks found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationInvalidFramework">
      <summary>
              Looks up a localized string similar to Invalid target framework '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationMissingDependency">
      <summary>
              Looks up a localized string similar to Missing dependency on '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationMissingProject">
      <summary>
              Looks up a localized string similar to Missing project '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationNoFrameworks">
      <summary>
              Looks up a localized string similar to No target frameworks specified..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationUAPSingleFramework">
      <summary>
              Looks up a localized string similar to UAP projects must contain exactly one target framework..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationZeroRestoreRequests">
      <summary>
              Looks up a localized string similar to Restore request does not contain any projects to restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UnableToExtractAssemblyMetadata">
      <summary>
              Looks up a localized string similar to Unable to extract metadata from '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UnableToFindBuildOutput">
      <summary>
              Looks up a localized string similar to Unable to find '{0}'. Make sure the project has been built..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UsingNuspecForMetadata">
      <summary>
              Looks up a localized string similar to Using '{0}' for metadata..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UsingPackagesConfigForDependencies">
      <summary>
              Looks up a localized string similar to Found packages.config. Using packages listed as dependencies.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_DuplicatePropertyKey">
      <summary>
              Looks up a localized string similar to '{0}' key already exists in Properties collection. Overriding value..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_FileDoesNotExist">
      <summary>
              Looks up a localized string similar to '{0}' was included in the project but doesn't exist. Skipping....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_MultiTarget">
      <summary>
              Looks up a localized string similar to Packages containing MSBuild targets and props files cannot be fully installed in projects targeting multiple frameworks. The MSBuild targets and props files have been ignored..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueDescription">
      <summary>
              Looks up a localized string similar to Description: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueSolution">
      <summary>
              Looks up a localized string similar to Solution: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueTitle">
      <summary>
              Looks up a localized string similar to Issue: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandPackageIssueSummary">
      <summary>
              Looks up a localized string similar to Issue found with package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_SemanticVersion">
      <summary>
              Looks up a localized string similar to Version "{0}" does not follow semantic versioning guidelines..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_SemanticVersionSolution">
      <summary>
              Looks up a localized string similar to Update your nuspec file or use the AssemblyInformationalVersion assembly attribute to specify a semantic version as described at http://semver.org..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_SemanticVersionTitle">
      <summary>
              Looks up a localized string similar to Use semantic versioning.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_UnresolvedFilePath">
      <summary>
              Looks up a localized string similar to '{0}' was included in the project but the path could not be resolved. Skipping....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_UnspecifiedField">
      <summary>
              Looks up a localized string similar to {0} was not specified. Using '{1}'..
            </summary>
    </member>
    <member name="T:NuGet.Commands.CommandRunnerUtility">
      <summary>
            Helper functions for shared command runners (push, delete, etc)
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Determine the target framework of an msbuild project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
      <summary>
            Determine the target framework of an msbuild project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworks(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Parse project framework strings into NuGetFrameworks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Parse existing nuget framework for .net core 4.5.1 or 4.5 and return compatible framework instance
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildStringUtility.Split(System.String)">
      <summary>
            Split on ; and trim. Null or empty inputs will return an
            empty array.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildStringUtility.TrimAndGetNullForEmpty(System.String)">
      <summary>
            Trims the provided string and converts empty strings to null.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildStringUtility.TrimAndExcludeNullOrEmpty(System.String[])">
      <summary>
            Trims the provided strings and excludes empty or null strings.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildStringUtility.IsTrue(System.String)">
      <summary>
            True if the property is set to true
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildStringUtility.IsTrueOrEmpty(System.String)">
      <summary>
            True if the property is set to true or empty.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RequestRuntimeUtility.GetRestoreRuntimes(NuGet.Commands.RestoreRequest)">
      <summary>
            Combines the project runtimes with the request.RequestedRuntimes.
            If those are both empty FallbackRuntimes is returned.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RequestRuntimeUtility.GetDefaultRestoreRuntimes(System.String,System.String)">
      <summary>
            Infer the runtimes from the current environment.
            </summary>
    </member>
    <member name="T:NuGet.Commands.Rules.AnalysisResources">
      <summary>
               A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.ResourceManager">
      <summary>
               Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.Culture">
      <summary>
               Overrides the current thread's CurrentUICulture property for all
               resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyOutsideLibDescription">
      <summary>
               Looks up a localized string similar to The assembly '{0}' is not inside the 'lib' folder and hence it won't be added as reference when the package is installed into a project..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyOutsideLibSolution">
      <summary>
               Looks up a localized string similar to Move it into the 'lib' folder if it should be referenced..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyOutsideLibTitle">
      <summary>
               Looks up a localized string similar to Assembly outside lib folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyUnderLibDescription">
      <summary>
               Looks up a localized string similar to The assembly '{0}' is placed directly under 'lib' folder. It is recommended that assemblies be placed inside a framework-specific folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyUnderLibSolution">
      <summary>
               Looks up a localized string similar to Move it into a framework-specific folder. If this assembly is targeted for multiple frameworks, ignore this warning..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.AssemblyUnderLibTitle">
      <summary>
               Looks up a localized string similar to Assembly not inside a framework folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.DefaultSpecValue">
      <summary>
               Looks up a localized string similar to The value "{0}" for {1} is a sample value and should be removed..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.DefaultSpecValueSolution">
      <summary>
               Looks up a localized string similar to Replace it with an appropriate value or remove it and rebuild your package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.DefaultSpecValueTitle">
      <summary>
               Looks up a localized string similar to Remove sample nuspec values..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidFrameworkDescription">
      <summary>
               Looks up a localized string similar to The folder '{0}' under 'lib' is not recognized as a valid framework name or a supported culture identifier..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidFrameworkSolution">
      <summary>
               Looks up a localized string similar to Rename it to a valid framework name..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidFrameworkTitle">
      <summary>
               Looks up a localized string similar to Invalid framework folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidPrereleaseDependency_Description">
      <summary>
               Looks up a localized string similar to A stable release of a package should not have a prerelease dependency..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidPrereleaseDependency_Solution">
      <summary>
               Looks up a localized string similar to Either modify the version spec of dependency "{0}" or update the version field in the nuspec..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.InvalidPrereleaseDependency_Title">
      <summary>
               Looks up a localized string similar to Prerelease dependency in stable package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.LegacyVersionDescription">
      <summary>
               Looks up a localized string similar to The package version '{0}' uses SemVer 2.0.0 or components of SemVer 1.0.0 that are not supported on legacy clients. This message can be ignored if the package is not intended for older clients..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.LegacyVersionSolution">
      <summary>
               Looks up a localized string similar to Change the package version to a SemVer 1.0.0 string. If the version contains a release label it must start with a letter..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.LegacyVersionTitle">
      <summary>
               Looks up a localized string similar to Package version not supported on legacy clients..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedInitScriptDescription">
      <summary>
               Looks up a localized string similar to The file '{0}' will be ignored by NuGet because it is not directly under 'tools' folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedInitScriptSolution">
      <summary>
               Looks up a localized string similar to Place the file directly under 'tools' folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedInitScriptTitle">
      <summary>
               Looks up a localized string similar to Init.ps1 script will be ignored..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedTransformFileDescription">
      <summary>
               Looks up a localized string similar to The transform file '{0}' is outside the 'content' folder and hence will not be transformed during installation of this package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedTransformFileSolution">
      <summary>
               Looks up a localized string similar to Move it into the 'content' folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MisplacedTransformFileTitle">
      <summary>
               Looks up a localized string similar to Transform file outside content folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MissingSummaryDescription">
      <summary>
               Looks up a localized string similar to The Description text is long but the Summary text is empty. This means the Description text will be truncated in the 'Manage NuGet Packages' dialog..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MissingSummarySolution">
      <summary>
               Looks up a localized string similar to Provide a brief summary of the package in the Summary field..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.MissingSummaryTitle">
      <summary>
               Looks up a localized string similar to Consider providing Summary text..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.PlaceholderFileInPackageDescription">
      <summary>
               Looks up a localized string similar to An empty folder placeholder file '{0}' is in a non-empty folder and should be removed..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.PlaceholderFileInPackageSolution">
      <summary>
               Looks up a localized string similar to Remove the file from the project..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.PlaceholderFileInPackageTitle">
      <summary>
               Looks up a localized string similar to Placeholder file in non-empty folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.ScriptOutsideToolsDescription">
      <summary>
               Looks up a localized string similar to The script file '{0}' is outside the 'tools' folder and hence will not be executed during installation of this package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.ScriptOutsideToolsSolution">
      <summary>
               Looks up a localized string similar to Move it into the 'tools' folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.ScriptOutsideToolsTitle">
      <summary>
               Looks up a localized string similar to PowerShell file outside tools folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnrecognizedScriptDescription">
      <summary>
               Looks up a localized string similar to The script file '{0}' is not recognized by NuGet and hence will not be executed during installation of this package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnrecognizedScriptSolution">
      <summary>
               Looks up a localized string similar to Rename it to install.ps1, uninstall.ps1 or init.ps1 and place it directly under 'tools'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnrecognizedScriptTitle">
      <summary>
               Looks up a localized string similar to Unrecognized PowerShell file..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnspecifiedDependencyVersion">
      <summary>
               Looks up a localized string similar to The version of dependency '{0}' is not specified..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnspecifiedDependencyVersionSolution">
      <summary>
               Looks up a localized string similar to Specify the version of dependency and rebuild your package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.UnspecifiedDependencyVersionTitle">
      <summary>
               Looks up a localized string similar to Specify version of dependencies..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.WinRTObsoleteDescription">
      <summary>
               Looks up a localized string similar to The file at '{0}' uses the obsolete 'WinRT' as the framework folder..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.WinRTObsoleteSolution">
      <summary>
               Looks up a localized string similar to Replace 'WinRT' or 'WinRT45' with 'NetCore45'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Rules.AnalysisResources.WinRTObsoleteTitle">
      <summary>
               Looks up a localized string similar to The framework name 'WinRT' is obsolete..
            </summary>
    </member>
    <member name="T:NuGet.Commands.Rules.LegacyVersionRule">
      <summary>
            Warn if the version is not parsable by older nuget clients.
            </summary>
      <remarks>This rule should be removed once more users move to SemVer 2.0.0 capable clients.</remarks>
    </member>
    <member name="P:NuGet.Commands.Rules.MisplacedAssemblyRule.ValidFolders">
      <summary>
            Folders that are expected to have .dll and .winmd files
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common417792.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common417792.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Common417792.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common417792.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Common.ActivityCorrelationId">
      <summary>
            Ambient correlation ID used to associate information pertaining to a current activity. A single activity
            engages multiple method calls at different layers. Sometimes it's necessary to identify separate calls
            belonging to the same activity if shared state is needed.
            </summary>
    </member>
    <member name="M:NuGet.Common.ActivityCorrelationId.StartNew">
      <summary>
            Starts a new activity activity correlation ID by updating ambient context value.
            </summary>
    </member>
    <member name="P:NuGet.Common.ActivityCorrelationId.Current">
      <summary>
            Returns current activity correlation ID or a default if not set previously.
            </summary>
    </member>
    <member name="T:NuGet.Common.AggregateEnumerableAsync`1">
      <summary>
            Aggregates from a list of already ordered enumerables
            The ordered result will contain only unique values
            If comparer/EqualityComparer are not provided the default ones for that type will be used.
            If the provided enumerables are not sorted already, the behavior is undefined
            </summary>
    </member>
    <member name="T:NuGet.Common.AggregateEnumeratorAsync`1">
      <summary>
            Aggregates from a list of already ordered enumerables
            The ordered result will contain only unique values
            If comparer/EqualityComparer are not provided the default ones for that type will be used.
            If the provided enumerables are not sorted already, the behavior is undefined
            </summary>
    </member>
    <member name="T:NuGet.Common.IEnumeratorAsync`1">
      <summary>
            Supports async iteration over a generic collection.
            Prior to calling Current, MoveNextAsync needs to be called otherwise the behavior is undefined 
            </summary>
      <typeparam name="T">The type of objects to enumerate.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.</typeparam>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:NuGet.Common.IEnumeratorAsync`1.MoveNextAsync">
      <summary>
            Moves the pointer to the next element in the collection. 
            </summary>
      <returns>
            Success status of the pointer move
            </returns>
    </member>
    <member name="P:NuGet.Common.IEnumeratorAsync`1.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            If <ref>MoveNextAsync</ref> has not been called prior to calling current the behavior is undefined
            If the last <ref>MoveNextAsync</ref> call returned false then the next call to Current should throw an InvalidOperationException
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="T:NuGet.Common.AsyncLazy`1">
      <summary>
            Wrapper class representing shorter syntax of Lazy&lt;Task&lt;T&gt;&gt;"/&gt;.
            Useful when declaring a lazy async factory of value T.
            </summary>
      <typeparam name="T">Value type</typeparam>
    </member>
    <member name="T:NuGet.Common.AsyncLazy">
      <summary>
            Shortcuts to common Lazy&lt;Task&lt;T&gt;&gt; constructor calls
            </summary>
    </member>
    <member name="M:NuGet.Common.ClientVersionUtility.GetNuGetAssemblyVersion">
      <summary>
            Find the current NuGet client version from the assembly info as a string.
            If no value can be found an InvalidOperationException will be thrown.
            </summary>
      <remarks>This can contain prerelease labels if AssemblyInformationalVersionAttribute exists.</remarks>
    </member>
    <member name="T:NuGet.Common.CryptoHashProvider">
      <summary>
            CryptoHashProvider helps calculate or verify hash based on SHA256 or SHA512 algorithms
            </summary>
    </member>
    <member name="F:NuGet.Common.CryptoHashProvider.SHA512HashAlgorithm">
      <summary>
            Server token used to represent that the hash being used is SHA 512
            </summary>
    </member>
    <member name="F:NuGet.Common.CryptoHashProvider.SHA256HashAlgorithm">
      <summary>
            Server token used to represent that the hash being used is SHA 256
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.#ctor">
      <summary>
            Creates an instance of CryptoHashProvider. Since the algorithm is not specified, SHA512 is assumed
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.#ctor(System.String)">
      <summary>
            Creates an instance of CryptoHashProvider using the hashAlgorithm
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.CalculateHash(System.IO.Stream)">
      <summary>
            Calculates the hash for a given stream
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.CalculateHash(System.Byte[])">
      <summary>
            Calculates the hash for a byte array
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.VerifyHash(System.Byte[],System.Byte[])">
      <summary>
            Verifies the hash for the given data and hash
            </summary>
    </member>
    <member name="P:NuGet.Common.CryptoHashProvider.AllowOnlyFipsAlgorithms">
      <summary>
            Determines if we are to only allow Fips compliant algorithms.
            </summary>
      <remarks>
            CryptoConfig.AllowOnlyFipsAlgorithm does not exist in Mono.
            </remarks>
    </member>
    <member name="T:NuGet.Common.DatetimeUtility">
      <summary>
            static class to provide datetime common utility apis
            </summary>
    </member>
    <member name="M:NuGet.Common.DatetimeUtility.ToReadableTimeFormat(System.TimeSpan)">
      <summary>
            take timespan n return in appropriate unit like ms, or seconds, or minutes, or hours
            </summary>
      <param name="time">timespan</param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Common.ExceptionUtilities">
      <summary>
            For internal use only
            </summary>
    </member>
    <member name="M:NuGet.Common.CollectorLogger.#ctor(NuGet.Common.ILogger)">
      <summary>
            Initializes an instance of the <see cref="T:NuGet.Common.CollectorLogger" />, while still
            delegating all log messages to the <param name="innerLogger" />.
            </summary>
    </member>
    <member name="P:NuGet.Common.ExceptionLogger.ShowStack">
      <summary>
            Determines whether the full exception (including stack trace) should be displayed to
            the user. In prerelease or dogfooding scenarios, it is useful to have a non-verbose
            logging level but, in the case of an unhandled exception, print the full exception for
            bug reporting.
            </summary>
      <returns>
            True if the exception stack should be displayed to the user. False, otherwise.
            </returns>
    </member>
    <member name="P:NuGet.Common.ICollectorLogger.Errors">
      <summary>
            Fetch all of the errors logged so far. This method is useful when error log messages
            should be redisplayed after the initial log message is emitted.
            </summary>
    </member>
    <member name="T:NuGet.Common.ILogger">
      <summary>
            A generic interface for logging.
            </summary>
    </member>
    <member name="M:NuGet.Common.NetworkProtocolUtility.ConfigureSupportedSslProtocols">
      <summary>
            This only has effect on .NET Framework (desktop). On .NET Core,
            <see cref="T:System.Net.ServicePointManager" /> is not available. Additionally,
            no API is available to configure the supported SSL protocols.
            </summary>
    </member>
    <member name="M:NuGet.Common.NetworkProtocolUtility.SetConnectionLimit">
      <summary>
            Set ServicePointManager.DefaultConnectionLimit
            </summary>
    </member>
    <member name="T:NuGet.Common.DirectoryUtility">
      <summary>
            Directory operation helpers.
            </summary>
    </member>
    <member name="M:NuGet.Common.DirectoryUtility.CreateSharedDirectory(System.String)">
      <summary>
            Creates all directories and subdirectories in the specified path unless they already exist.
            New directories can be read and written by all users.
            </summary>
    </member>
    <member name="T:NuGet.Common.FileUtility">
      <summary>
            File operation helpers.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.GetTempFilePath(System.String)">
      <summary>
            Get the full path to a new temp file
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.DeleteWithLock(System.String)">
      <summary>
            Lock around the output path.
            Delete the existing file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.ReplaceWithLock(System.Action{System.String},System.String)">
      <summary>
            Lock around the output path.
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Replace(System.Action{System.String},System.String)">
      <summary>
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Replace(System.String,System.String)">
      <summary>
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Move(System.String,System.String)">
      <summary>
            Move a file with retries.
            This will not overwrite
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Delete(System.String)">
      <summary>
            Delete a file with retries.
            </summary>
    </member>
    <member name="T:NuGet.Common.INuGetPathContext">
      <summary>
            Common NuGet paths. These values may be overridden in NuGet.Config or by 
            environment variables, resolving the paths here requires NuGet.Configuration.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.UserPackageFolder">
      <summary>
            User package folder directory.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.FallbackPackageFolders">
      <summary>
            Fallback package folder locations.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.HttpCacheFolder">
      <summary>
            Http file cache.
            </summary>
    </member>
    <member name="T:NuGet.Common.NuGetEnvironment.SpecialFolder">
      <summary>
            Since <see cref="T:System.Environment.SpecialFolder" /> is not available on .NET Core, we have to
            make our own and re-implement the functionality. On .NET Framework, we can use the
            built-in functionality.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathResolver.GetMatches``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Returns a collection of files from the source that matches the wildcard.
            </summary>
      <param name="source">The collection of files to match.</param>
      <param name="getPath">Function that returns the path to filter a package file </param>
      <param name="wildcards">The wildcards to apply to match the path with.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Common.PathResolver.FilterPackageFiles``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes files from the source that match any wildcard.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathResolver.IsWildcardSearch(System.String)">
      <summary>
            Returns true if the path contains any wildcard characters.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetStringComparerBasedOnOS">
      <summary>
            Returns OrdinalIgnoreCase windows and mac. Ordinal for linux.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetUniquePathsBasedOnOS(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Returns distinct orderd paths based on the file system case sensitivity.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetRelativePath(System.String,System.String)">
      <summary>
            Returns path2 relative to path1, with Path.DirectorySeparatorChar as separator
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetRelativePath(System.String,System.String,System.Char)">
      <summary>
            Returns path2 relative to path1, with given path separator
            </summary>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidSource(System.String)">
      <summary>
            Validates that a source is a valid path or url.
            </summary>
      <param name="source">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidLocalPath(System.String)">
      <summary>
            Validates that path is properly formatted as a local path. 
            </summary>
      <remarks>
            On Windows, a valid local path must starts with the drive letter.
            Example: C:\, C:\path, C:\path\to\
            Bad: C:\invalid\*\"\chars
            </remarks>
      <param name="path">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidUncPath(System.String)">
      <summary>
            Validates that path is properly formatted as an UNC path. 
            </summary>
      <remarks>
            Example: \\server\share, \\server\share\path, \\server\share\path\to\
            Bad: \\server\invalid\*\"\chars
            </remarks>
      <param name="path">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidUrl(System.String)">
      <summary>
            Validates that url is properly formatted as an URL based on .NET <see cref="T:System.Uri">Uri</see> class.
            </summary>
      <param name="url">The url to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectConfigFileName">
      <summary>
            project.json
            </summary>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectConfigFileEnding">
      <summary>
            .project.json
            </summary>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectLockFileName">
      <summary>
            Lock file name
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectConfigPath(System.String,System.String)">
      <summary>
            Finds the projectName.project.json in a directory. If no projectName.project.json exists
            the default project.json path will be returned regardless of existance.
            </summary>
      <returns>Returns the full path to the project.json file.</returns>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectConfigWithProjectName(System.String)">
      <summary>
            Creates a projectName.project.json file name.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectLockFileNameWithProjectName(System.String)">
      <summary>
            Creates a projectName.project.lock.json file name.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetLockFilePath(System.String)">
      <summary>
            Create the lock file path from the config file path.
            If the config file includes a project name the 
            lock file will include the name also.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectNameFromConfigFileName(System.String)">
      <summary>
            Parses a projectName.project.json file name into a project name.
            If there is no project name null will be returned.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.IsProjectConfig(System.String)">
      <summary>
            True if the file is a project.json or projectname.project.json file.
            </summary>
    </member>
    <member name="T:NuGet.Common.Preprocessor">
      <summary>
            Simple token replacement system for content files.
            </summary>
    </member>
    <member name="T:NuGet.Common.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.AbsolutePathRequired">
      <summary>
              Looks up a localized string similar to An absolute path is required: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Argument_Must_Be_GreaterThanOrEqualTo">
      <summary>
              Looks up a localized string similar to Value must be greater than or equal to {0}.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.ArgumentNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Error_FailedToCreateRandomFile">
      <summary>
              Looks up a localized string similar to Failed to create random file for dotnet add pkg command..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.NoPackageFoldersFound">
      <summary>
              Looks up a localized string similar to At least one package folder path must be provided..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.PackageFolderNotFound">
      <summary>
              Looks up a localized string similar to Package folder not found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnableToDetemineClientVersion">
      <summary>
              Looks up a localized string similar to Unable to determine the current NuGet client version..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnauthorizedLockFail">
      <summary>
              Looks up a localized string similar to Unable to obtain lock file access on '{0}' for operations on '{1}'. This may mean that a different user or administator is holding this lock and that this process does not have permission to access it. If no other process is currently performing an operation on this file it may mean that an earlier NuGet process crashed and left an inaccessible lock file, in this case removing the file '{0}' will allow NuGet to continue..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnsupportedHashAlgorithm">
      <summary>
              Looks up a localized string similar to Hash algorithm '{0}' is unsupported. Supported algorithms include: SHA512 and SHA256..
            </summary>
    </member>
    <member name="T:NuGet.Common.Tokenizer">
      <summary>
            This class is used to parse string into tokens.    
            There are two types of tokens: variables, e.g. "$variable$", or text. 
            The dollar sign can be escaped using $$.
            A variable contains only word characters.
            
            Examples:
            - "a $b$ c" is parsed into 
              {text, "a "}, {variable, "b"}, {text, " c"}.
            - "a $$b$$ c" is parsed into
              {text, "a $b$ c"}.
            - "a $b$ $c" is parsed into
              {text, "a "}, {variable, "b"}, {text, " $c"}.
            - "a $b$$c$" is parsed into
              {text, "a "}, {variable, "b"}, {variable, "c"}.
            - "a $b c$d$" is parsed into 
              {text, "a $b c"}, {variable, "d"} (because space is not a word character).
            </summary>
    </member>
    <member name="M:NuGet.Common.Tokenizer.Read">
      <summary>
            Gets the next token.
            </summary>
      <returns>The parsed token. Or null if no more tokens are available.</returns>
    </member>
    <member name="M:NuGet.Common.UriUtility.CreateSourceUri(System.String,System.UriKind)">
      <summary>
            Same as "new Uri" except that it can handle UNIX style paths that start with '/'
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.TryCreateSourceUri(System.String,System.UriKind)">
      <summary>
            Same as "Uri.TryCreate" except that it can handle UNIX style paths that start with '/'
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.UrlEncodeOdataParameter(System.String)">
      <summary>
            Provides Uri encoding for V2 servers in the same way that NuGet.Core.dll encoded urls.
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.GetLocalPath(System.String)">
      <summary>
            Convert a file:// URI to a local path.
            </summary>
      <returns>If the input can be parsed this will return Uri.LocalPath, if the input 
            is not a URI or fails to parse the original string will be returned.</returns>
      <param name="localOrUriPath">Possible file:// URI path or local path.</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration436356.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration436356.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Configuration436356.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration436356.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Proxy">
      <summary>
            Indicates that the request credentials are to be used to access a proxy.
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Unauthorized">
      <summary>
            Indicates that the remote server rejected the previous request as unauthorized. This 
            suggests that the server does not know who the caller is (i.e. the caller is not
            authenticated).
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Forbidden">
      <summary>
            Indicates that the remote server rejected the previous request as forbidden. This
            suggests that the server knows who the caller is (i.e. the caller is authorized) but
            is not allowed to access the request resource. A different set of credentials could
            solve this failure.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ICredentialService.HandlesDefaultCredentials">
      <summary>
            Gets a value indicating whether this credential service wants to handle "default credentials" specially,
            instead of relying on DefaultNetworkCredentials
            </summary>
    </member>
    <member name="F:NuGet.Configuration.NuGetConstants.DefaultGalleryServerUrl">
      <summary>
            NuGet.org gallery Url used as a source display name and as a default "id" when storing nuget.org API key.
            </summary>
      <remarks>
            Albeit this url is not actual feed we should keep it unchanged for back-compat with earlier NuGet versions.
            Typical scenario leading to adding this url to config file is to run setApiKey command without a source:
            nuget.exe setApiKey XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
            </remarks>
    </member>
    <member name="F:NuGet.Configuration.PackageSource.DefaultProtocolVersion">
      <summary>
            The feed version for NuGet prior to v3.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.TrySourceAsUri">
      <summary>
            Returns null if Source is an invalid URI
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.SourceUri">
      <summary>
            Throws if Source is an invalid URI
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.IsOfficial">
      <summary>
            This does not represent just the NuGet Official Feed alone
            It may also represent a Default Package Source set by Configuration Defaults
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.ProtocolVersion">
      <summary>
            Gets or sets the protocol version of the source. Defaults to 2.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.IsLocal">
      <summary>
            True if the source path is file based. Unc shares are not included.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.Origin">
      <summary>
            Gets the <see cref="T:NuGet.Configuration.ISettings" /> that this source originated from. May be null.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.PackageSourceCredential">
      <summary>
            Represents credentials required to authenticate user within package source web requests.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.IsValid">
      <summary>
            Verifies if object contains valid data, e.g. not empty user name and password.
            </summary>
      <returns>True if credentials object is valid</returns>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Instantiates the credential instance out of raw values read from a config file.
            </summary>
      <param name="source">Associated source ID (needed for reporting errors)</param>
      <param name="username">User name</param>
      <param name="passwordText">Password as stored in config file</param>
      <param name="isPasswordClearText">Hints if password provided in clear text</param>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.FromUserInput(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Creates new instance of credential object out values provided by user.
            </summary>
      <param name="source">Source ID needed for reporting errors if any</param>
      <param name="username">User name</param>
      <param name="password">Password text in clear</param>
      <param name="storePasswordInClearText">Hints if the password should be stored in clear text on disk.</param>
      <returns>New instance of <see cref="T:NuGet.Configuration.PackageSourceCredential" /></returns>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Username">
      <summary>
            User name
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.PasswordText">
      <summary>
            Password text as stored in config file. May be encrypted.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.IsPasswordClearText">
      <summary>
            Indicates if password is stored in clear text.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Password">
      <summary>
            Retrieves password in clear text. Decrypts on-demand.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Source">
      <summary>
            Associated source ID
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.LoadPackageSources">
      <summary>
            Returns PackageSources if specified in the config file. Else returns the default sources specified in the
            constructor.
            If no default values were specified, returns an empty sequence.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.OnPackageSourcesChanged">
      <summary>
            Fires event PackageSourcesChanged
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.SaveActivePackageSource(NuGet.Configuration.PackageSource)">
      <summary>
            Saves the <paramref name="source" /> as the active source.
            </summary>
      <param name="source">
      </param>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceProvider.ActivePackageSourceName">
      <summary>
            Gets the name of the ActivePackageSource from NuGet.Config
            </summary>
    </member>
    <member name="T:NuGet.Configuration.IProxyCredentialCache">
      <summary>
        <see cref="T:System.Net.CredentialCache" />-like interface with Update credential semantics rather than Add/Remove
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IProxyCredentialCache.UpdateCredential(System.Uri,System.Net.NetworkCredential)">
      <summary>
            Add or update proxy credential
            </summary>
      <param name="proxyAddress">Proxy network address</param>
      <param name="credentials">New credential object</param>
    </member>
    <member name="P:NuGet.Configuration.IProxyCredentialCache.Version">
      <summary>
            Tracks the cache version. Changes every time proxy credential is updated.
            </summary>
    </member>
    <member name="F:NuGet.Configuration.ProxyCache._originalSystemProxy">
      <summary>
            Capture the default System Proxy so that it can be re-used by the IProxyFinder
            because we can't rely on WebRequest.DefaultWebProxy since someone can modify the DefaultWebProxy
            property and we can't tell if it was modified and if we are still using System Proxy Settings or not.
            One limitation of this method is that it does not look at the config file to get the defined proxy
            settings.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ProxyCache.IsSystemProxySet(System.Uri)">
      <summary>
            Return true or false if connecting through a proxy server
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Configuration.WebProxy">
      <summary>
            Internal implementation of <see cref="T:System.Net.IWebProxy" /> mirroring default desktop one.
            Introduced for XPlat coreFx support.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Value cannot be null or empty string..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Error_EncryptionUnsupported">
      <summary>
              Looks up a localized string similar to Encryption is not supported on non-Windows platforms..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Error_NoWritableConfig">
      <summary>
              Looks up a localized string similar to There are no writable config files..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.FileDoesNotExist">
      <summary>
              Looks up a localized string similar to File '{0}' does not exist..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.InvalidNullSettingsOperation">
      <summary>
              Looks up a localized string similar to "{0}" cannot be called on a NullSettings. This may be caused on account of insufficient permissions to read or write to "%AppData%\NuGet\NuGet.config"..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.MustContainAbsolutePath">
      <summary>
              Looks up a localized string similar to '{0}' must contain an absolute path '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.PackageSource_Invalid">
      <summary>
              Looks up a localized string similar to The package source does not belong to the collection of available sources..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.RelativeEnvVarPath">
      <summary>
              Looks up a localized string similar to Environment variable '{0}' must contain an absolute path, the full path of '{1}' cannot be determined..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Settings_FileName_Cannot_Be_A_Path">
      <summary>
              Looks up a localized string similar to Parameter 'fileName' to Settings must be just a fileName and not a path.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigInvalidOperation">
      <summary>
              Looks up a localized string similar to NuGet.Config is malformed. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigInvalidXml">
      <summary>
              Looks up a localized string similar to NuGet.Config is not valid XML. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigRootInvalid">
      <summary>
              Looks up a localized string similar to NuGet.Config does not contain the expected root element: 'configuration'. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigUnauthorizedAccess">
      <summary>
              Looks up a localized string similar to Failed to read NuGet.Config due to unauthorized access. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Unknown_Config_Exception">
      <summary>
              Looks up a localized string similar to Unexpected failure reading NuGet.Config. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UnsupportedDecryptPassword">
      <summary>
              Looks up a localized string similar to Password decryption is not supported on .NET Core for this platform. The following feed uses an encrypted password: '{0}'. You can use a clear text password as a workaround..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UnsupportedEncryptPassword">
      <summary>
              Looks up a localized string similar to Password encryption is not supported on .NET Core for this platform. The following feed try to use an encrypted password: '{0}'. You can use a clear text password as a workaround..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UserSettings_UnableToParseConfigFile">
      <summary>
              Looks up a localized string similar to Unable to parse config file '{0}'..
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ConfigurationDefaults.#ctor(System.String,System.String)">
      <summary>
            An internal constructor MAINLY INTENDED FOR TESTING THE CLASS. But, the product code is only expected to
            use the static Instance property
            Only catches FileNotFoundException. Will throw all exceptions including other IOExceptions and
            XmlExceptions for invalid xml and so on
            </summary>
      <param name="directory">The directory that has the NuGetDefaults.Config</param>
      <param name="configFile">Name of the NuGetDefaults.Config</param>
    </member>
    <member name="T:NuGet.Configuration.ISettings">
      <summary>
            Interface to expose NuGet Settings
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetValue(System.String,System.String,System.Boolean)">
      <summary>
            Gets a value for the given key from the given section
            If isPath is true, then the value represents a path. If the path value is already rooted, it is simply
            returned
            Otherwise, path relative to ISettings.Root is returned
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetSettingValues(System.String,System.Boolean)">
      <summary>
            Gets all the values under section
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetNestedValues(System.String,System.String)">
      <summary>
            Gets all the values under section
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.SetValues(System.String,System.Collections.Generic.IReadOnlyList{NuGet.Configuration.SettingValue})">
      <summary>
            Sets the values under the specified <paramref name="section" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.UpdateSections(System.String,System.Collections.Generic.IReadOnlyList{NuGet.Configuration.SettingValue})">
      <summary>
            Updates the <paramref name="values" /> across multiple <see cref="T:NuGet.Configuration.ISettings" /> instances in the hierarchy.
            Values are updated in the <see cref="T:NuGet.Configuration.ISettings" /> with the nearest priority.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="P:NuGet.Configuration.ISettings.Root">
      <summary>
            Folder under which the config file is present
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ISettings.FileName">
      <summary>
            The file name of the config file. Joining <see cref="P:NuGet.Configuration.ISettings.Root" /> and
            <see cref="P:NuGet.Configuration.ISettings.FileName" /> results in the full path to the config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ISettings.Priority">
      <summary>
            Enumerates the sequence of <see cref="T:NuGet.Configuration.ISettings" /> instances used to fetch settings
            values (e.g. with <see cref="M:NuGet.Configuration.ISettings.GetValue(System.String,System.String,System.Boolean)" />). This enumeration includes this instance
            itself.
            </summary>
    </member>
    <member name="E:NuGet.Configuration.ISettings.SettingsChanged">
      <summary>
            Event raised when the setting have been changed.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.NuGetPathContext.Create(NuGet.Configuration.ISettings)">
      <summary>
            Load paths from already loaded settings.
            </summary>
      <param name="settings">NuGet.Config settings.</param>
    </member>
    <member name="M:NuGet.Configuration.NuGetPathContext.Create(System.String)">
      <summary>
            Load settings based on the solution or project root directory. NuGet.Config files will 
            be discovered based on this path. The machine wide config will also be loaded.
            </summary>
      <param name="settingsRoot">Root directory of the solution or project.</param>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.FallbackPackageFolders">
      <summary>
            Fallback package folders. There many be zero or more of these.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.UserPackageFolder">
      <summary>
            User global packages folder.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.HttpCacheFolder">
      <summary>
            User level http cache.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.Settings">
      <summary>
            Concrete implementation of ISettings to support NuGet Settings
            </summary>
    </member>
    <member name="F:NuGet.Configuration.Settings.DefaultSettingsFileName">
      <summary>
            Default file name for a settings file is 'NuGet.config'
            Also, the machine level setting file at '%APPDATA%\NuGet' always uses this name
            </summary>
    </member>
    <member name="F:NuGet.Configuration.Settings.OrderedSettingsFileNames">
      <summary>
            NuGet config names with casing ordered by precedence.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String)">
      <summary>
            Load default settings based on a directory.
            This includes machine wide settings.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String,System.String,NuGet.Configuration.IMachineWideSettings)">
      <summary>
            Loads user settings from the NuGet configuration files. The method walks the directory
            tree in <paramref name="root" /> up to its root, and reads each NuGet.config file
            it finds in the directories. It then reads the user specific settings,
            which is file <paramref name="configFileName" />
            in <paramref name="root" /> if <paramref name="configFileName" /> is not null,
            If <paramref name="configFileName" /> is null, the user specific settings file is
            %AppData%\NuGet\NuGet.config.
            After that, the machine wide settings files are added.
            </summary>
      <remarks>
            For example, if <paramref name="root" /> is c:\dir1\dir2, <paramref name="configFileName" />
            is "userConfig.file", the files loaded are (in the order that they are loaded):
            c:\dir1\dir2\nuget.config
            c:\dir1\nuget.config
            c:\nuget.config
            c:\dir1\dir2\userConfig.file
            machine wide settings (e.g. c:\programdata\NuGet\Config\*.config)
            </remarks>
      <param name="root">
            The file system to walk to find configuration files.
            Can be null.
            </param>
      <param name="configFileName">The user specified configuration file.</param>
      <param name="machineWideSettings">
            The machine wide settings. If it's not null, the
            settings files in the machine wide settings are added after the user sepcific
            config file.
            </param>
      <returns>The settings object loaded.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadSpecificSettings(System.String,System.String)">
      <summary>
            Loads Specific NuGet.Config file. The method only loads specific config file 
            which is file <paramref name="configFileName" />from <paramref name="root" />.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String,System.String,NuGet.Configuration.IMachineWideSettings,System.Boolean,System.Boolean)">
      <summary>
            For internal use only
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadMachineWideSettings(System.String,System.String[])">
      <summary>
            Loads the machine wide settings.
            </summary>
      <remarks>
            For example, if <paramref name="paths" /> is {"IDE", "Version", "SKU" }, then
            the files loaded are (in the order that they are loaded):
            %programdata%\NuGet\Config\IDE\Version\SKU\*.config
            %programdata%\NuGet\Config\IDE\Version\*.config
            %programdata%\NuGet\Config\IDE\*.config
            %programdata%\NuGet\Config\*.config
            </remarks>
      <param name="root">The file system in which the settings files are read.</param>
      <param name="paths">The additional paths under which to look for settings files.</param>
      <returns>The list of settings read.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.GetSettingsFileNames(System.String)">
      <remarks>
            Order is most significant (e.g. applied last) to least significant (applied first)
            ex:
            c:\someLocation\nuget.config
            c:\nuget.config
            </remarks>
    </member>
    <member name="M:NuGet.Configuration.Settings.GetSettingsFileNameFromDir(System.String)">
      <summary>
            Checks for each possible casing of nuget.config in the directory. The first match is
            returned. If there are no nuget.config files null is returned.
            </summary>
      <remarks>For windows <see cref="F:NuGet.Configuration.Settings.OrderedSettingsFileNames" /> contains a single casing since
            the file system is case insensitive.</remarks>
    </member>
    <member name="P:NuGet.Configuration.Settings.Root">
      <summary>
            Folder under which the config file is present
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Settings.ConfigFilePath">
      <summary>
            Full path to the ConfigFile corresponding to this Settings object
            </summary>
    </member>
    <member name="T:NuGet.Configuration.SettingValue">
      <summary>
            Represents a single setting value in a settings file
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Key">
      <summary>
            Represents the key of the setting
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Value">
      <summary>
            Represents the value of the setting
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.OriginalValue">
      <summary>
            original value of the source as in NuGet.Config
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.IsMachineWide">
      <summary>
            IsMachineWide tells if the setting is machine-wide or not
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Priority">
      <summary>
            The priority of this setting in the nuget.config hierarchy. Bigger number means higher priority
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Origin">
      <summary>
            Gets the <see cref="T:NuGet.Configuration.ISettings" /> that provided this value.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.AdditionalData">
      <summary>
            Gets additional values with the specified setting.
            </summary>
      <remarks>
            When reading from an XML based settings file, this includes all attributes on the element
            other than the <c>Key</c> and <c>Value</c>.
            </remarks>
    </member>
    <member name="T:NuGet.Configuration.XPlatMachineWideSetting">
      <summary>
            Machine wide settings based on the default machine wide config directory.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.IExtensionLocator">
      <summary>
            Provides a common facility for locating extensions
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IExtensionLocator.FindExtensions">
      <summary>
            Find paths to all extensions
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IExtensionLocator.FindCredentialProviders">
      <summary>
            Find paths to all credential providers
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetConfigValue(NuGet.Configuration.ISettings,System.String,System.Boolean,System.Boolean)">
      <summary>
            Retrieves a config value for the specified key
            </summary>
      <param name="settings">The settings instance to retrieve </param>
      <param name="key">The key to look up</param>
      <param name="decrypt">Determines if the retrieved value needs to be decrypted.</param>
      <param name="isPath">Determines if the retrieved value is returned as a path.</param>
      <returns>Null if the key was not found, value from config otherwise.</returns>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.SetConfigValue(NuGet.Configuration.ISettings,System.String,System.String,System.Boolean)">
      <summary>
            Sets a config value in the setting.
            </summary>
      <param name="settings">The settings instance to store the key-value in.</param>
      <param name="key">The key to store.</param>
      <param name="value">The value to store.</param>
      <param name="encrypt">Determines if the value needs to be encrypted prior to storing.</param>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.DeleteConfigValue(NuGet.Configuration.ISettings,System.String)">
      <summary>
            Deletes a config value from settings
            </summary>
      <param name="settings">The settings instance to delete the key from.</param>
      <param name="key">The key to delete.</param>
      <returns>True if the value was deleted, false otherwise.</returns>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetFallbackPackageFolders(NuGet.Configuration.ISettings)">
      <summary>
            Read fallback folders from the environment variable or from nuget.config.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetFallbackPackageFoldersFromConfig(NuGet.Configuration.ISettings)">
      <summary>
            Read fallback folders only from nuget.config.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetHttpCacheFolder">
      <summary>
            Get the HTTP cache folder from either an environment variable or a default.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetDefaultPushSource(NuGet.Configuration.ISettings)">
      <summary>
            The DefaultPushSource can be:
            - An absolute URL
            - An absolute file path
            - A relative file path
            - The name of a registered source from a config file
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.VerifyPathIsRooted(System.String,System.String)">
      <summary>
            Throw if a path is relative.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core463335.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core463335.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.DependencyResolver.Core463335.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core463335.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.GraphEdge`1">
      <summary>
            GraphEdge holds a reference to the parent node, the incoming edge to the parent, and
            the out going edge to the current position of the walk.
            
            Root -&gt; OuterEdge -&gt; Node -&gt; Edge -&gt; (Current Node)
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.OuterEdge">
      <summary>
            Incoming edge to <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Item" />.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.Item">
      <summary>
            Graph node between <see cref="P:NuGet.DependencyResolver.GraphEdge`1.OuterEdge" /> and <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Edge" />.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.Edge">
      <summary>
            Outgoing edge from <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Item" />.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.LibraryRangeCacheKey">
      <summary>
            Helper class to hold a library range and framework.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LibraryRangeCacheKey.Framework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LibraryRangeCacheKey.LibraryRange">
      <summary>
            Library range information.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.PackagingUtility.GetLibraryDependencyFromNuspec(NuGet.Packaging.Core.PackageDependency)">
      <summary>
            Convert a nuspec dependency to a library dependency.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.LocalMatch">
      <summary>
            Extends <see cref="T:NuGet.DependencyResolver.RemoteMatch" /> to add a reference to the full Library.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalMatch.LocalLibrary">
      <summary>
            Full local Library metadata
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalMatch.LocalProvider">
      <summary>
            The local provider where the library was found.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.RemoteWalkContext.FindLibraryEntryCache">
      <summary>
            Library entry cache.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.RemoteWalkContext.PackageFileCache">
      <summary>
            Files contained in a package.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.RemoteWalkContext.IsMsBuildBased">
      <summary>
            True if this is a csproj or similar project. Xproj should be false.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks480403.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks480403.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Frameworks480403.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks480403.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkPrecedenceSorter">
      <summary>
            Sorts frameworks according to the framework mappings
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkFullComparer">
      <summary>
            A case insensitive compare of the framework, version, and profile
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkNameComparer">
      <summary>
            A case insensitive compare of the framework name only
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkSorter">
      <summary>
            Sorts NuGet Frameworks in a consistent way for package readers.
            The order is not particularly useful here beyond making things deterministic
            since it compares completely different frameworks.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.CompatibilityCacheKey">
      <summary>
            Internal cache key used to store framework compatibility.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Check if the frameworks are compatible.
            </summary>
      <param name="target">Project framework</param>
      <param name="candidate">Other framework to check against the project framework</param>
      <returns>True if framework supports other</returns>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatibleCore(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Actual compatibility check without caching
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.GetEquivalentFrameworksClosure(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Find all equivalent frameworks, and their equivalent frameworks.
            Example:
            Mappings:
            A &lt;‒&gt; B
            B &lt;‒&gt; C
            C &lt;‒&gt; D
            For A we need to find B, C, and D so we must retrieve equivalent frameworks for A, B, and C
            also as we discover them.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.CompatibilityTable">
      <summary>
            Creates a table of compatible frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.HasFramework(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework is in the table.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.GetNearest(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Gives the smallest set of frameworks from the table that cover everything the given framework would cover.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.TryGetCompatible(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the list of all frameworks compatible with the given framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.DefaultFrameworkMappings.Instance">
      <summary>
            Singleton instance of the default framework mappings.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.DefaultPortableFrameworkMappings">
      <summary>
            Contains the standard portable framework mappings
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.DefaultPortableFrameworkMappings.Instance">
      <summary>
            Static instance of the portable framework mappings
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkCompatibilityListProvider.GetFrameworksSupporting(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get a list of frameworks supporting the provided framework. This list
            is not meant to be exhaustive but is instead meant to be human-readable.
            Ex: netstandard1.5 -&gt; netstandardapp1.5, net462, dnxcore50, ...
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkCompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Ex: IsCompatible(net45, net40) -&gt; true
            Ex: IsCompatible(net40, net45) -&gt; false
            </summary>
      <param name="framework">Project target framework</param>
      <param name="other">Library framework that is going to be installed</param>
      <returns>True if framework supports other</returns>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkMappings">
      <summary>
            A raw list of framework mappings. These are indexed by the framework name provider and in most cases all
            mappings are
            mirrored so that the IFrameworkMappings implementation only needs to provide the minimum amount of
            mappings.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierSynonyms">
      <summary>
            Synonym ‒&gt; Identifier
            Ex: NET Framework ‒&gt; .NET Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierShortNames">
      <summary>
            Ex: .NET Framework ‒&gt; net
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.ProfileShortNames">
      <summary>
            Ex: WindowsPhone ‒&gt; wp
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworks">
      <summary>
            Equal frameworks. Used for legacy conversions.
            ex: Framework: Win8 &lt;‒&gt; Framework: NetCore45 Platform: Win8
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentProfiles">
      <summary>
            Framework, EquivalentProfile1, EquivalentProfile2
            Ex: Silverlight, WindowsPhone71, WindowsPhone
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.SubSetFrameworks">
      <summary>
            Frameworks which are subsets of others.
            Ex: .NETCore ‒&gt; .NET
            Everything in .NETCore maps to .NET and is one way compatible. Version numbers follow the same format.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings">
      <summary>
            Additional framework compatibility rules beyond name and version matching.
            Ex: .NETFramework supports ‒&gt; Native
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence">
      <summary>
            Ordered list of framework identifiers. The first framework in the list will be preferred over other 
            framework identifiers. This is enable better tie breaking in scenarios where legacy frameworks are 
            equivalently compatible to a new framework.
            Example: UAP10.0 ‒&gt; win81, wpa81
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence">
      <summary>
            Same as <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" /> but is only referred to if all of the packages
            in consideration are package based (determined by <see cref="P:NuGet.Frameworks.NuGetFramework.IsPackageBased" />).
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworkPrecedence">
      <summary>
            Only used to choose between frameworks that are equivalent. This favors more human-readable target
            frameworks identifiers.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.ShortNameReplacements">
      <summary>
            Rewrite folder short names to the given value.
            Ex: dotnet50 ‒&gt; dotnet
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.FullNameReplacements">
      <summary>
            Rewrite full framework names to the given value.
            Ex: .NETPlatform,Version=v0.0 ‒&gt; .NETPlatform,Version=v5.0
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetIdentifier(System.String,System.String@)">
      <summary>
            Returns the official framework identifier for an alias or short name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortIdentifier(System.String,System.String@)">
      <summary>
            Gives the short name used for folders in NuGet
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetProfile(System.String,System.String,System.String@)">
      <summary>
            Get the official profile name from the short name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortProfile(System.String,System.String,System.String@)">
      <summary>
            Returns the shortened version of the profile name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetVersion(System.String,System.Version@)">
      <summary>
            Parses a version string using single digit rules if no dots exist
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetVersionString(System.String,System.Version)">
      <summary>
            Returns a shortened version. If all digits are single digits no dots will be used.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfileNumber(System.String,System.Int32@)">
      <summary>
            Tries to parse the portable profile number out of a profile.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfile(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Int32@)">
      <summary>
            Looks up the portable profile number based on the framework list.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a profile string.
            Profile can be either the number in format: Profile=7, or the shortened NuGet version: net45+win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Parses a shortened portable framework profile list.
            Ex: net45+win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableCompatibilityMappings(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
      <summary>
            Returns ranges of frameworks that are known to be supported by the given portable profile number.
            Ex: Profile7 -&gt; netstandard1.1
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns a list of all possible substitutions where the framework name
            have equivalents.
            Ex: sl3 -&gt; wp8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.FrameworkRange,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Gives all substitutions for a framework range.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetCompatibilityMappings(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
      <summary>
            Returns ranges of frameworks that are known to be supported by the given framework.
            Ex: net45 -&gt; native
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetSubSetFrameworks(System.String,System.Collections.Generic.IEnumerable{System.String}@)">
      <summary>
            Returns all sub sets of the given framework.
            Ex: .NETFramework -&gt; .NETCore
            These will have the same version, but a different framework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            The ascending order of frameworks should be based on the following ordered groups:
            
            1. Non-package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" />.
            2. Other non-package-based frameworks.
            3. Package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence" />.
            4. Other package-based frameworks.
            
            For group #1 and #3, the order within the group is based on the order of the respective precedence list.
            For group #2 and #4, the order is the original order in the incoming list. This should later be made
            consistent between different input orderings by using the <see cref="T:NuGet.Frameworks.NuGetFrameworkSorter" />.
            </summary>
      <remarks>netcore50 is a special case since netcore451 is not packages based, but netcore50 is.
            This sort will treat all versions of netcore as non-packages based.</remarks>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Used to pick between two equivalent frameworks. This is meant to favor the more human-readable
            framework. Note that this comparison does not validate that the provided frameworks are indeed
            equivalent (e.g. with
            <see cref="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)" />).
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetShortNameReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Returns folder short names rewrites.
            Ex: dotnet50 -&gt; dotnet
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetFullNameReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Returns full name rewrites.
            Ex: .NETPlatform,Version=v0.0 -&gt; .NETPlatform,Version=v5.0
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetNetStandardVersions">
      <summary>
            Returns all versions of .NETStandard in ascending order.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetCompatibleCandidates">
      <summary>
            Returns a list of frameworks that could be compatible with .NETStandard.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkSpecific">
      <summary>
            A group or object that is specific to a single target framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkSpecific.TargetFramework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkTargetable">
      <summary>
            Use this to expose the list of target frameworks an object can be used for.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkTargetable.SupportedFrameworks">
      <summary>
            All frameworks supported by the parent
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileFrameworks">
      <summary>
            Ex: 5 -&gt; net4, win8
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileOptionalFrameworks">
      <summary>
            Additional optional frameworks supported in a portable profile.
            Ex: 5 -&gt; MonoAndroid1+MonoTouch1
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.CompatibilityMappings">
      <summary>
            Compatibility mapping for portable profiles. This is a separate compatibility from that in
            <see cref="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings" />.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FallbackFramework.Fallback">
      <summary>
            List framework to fall back to.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkConstants.CommonFrameworks">
      <summary>
            Interned frameworks that are commonly used in NuGet
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkExpander">
      <summary>
            FrameworkExpander finds all equivalent and compatible frameworks for a NuGetFramework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkExpander.Expand(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Return all possible equivalent, subset, and known compatible frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkExpander.ExpandInternal(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Finds all expansions using the mapping provider
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.IsDesktop(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the Framework is .NETFramework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
      <summary>
            Return the item with the target framework nearest the project framework
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.FrameworkNameProvider._identifierSynonyms">
      <summary>
            Contains identifier -&gt; identifier
            Ex: .NET Framework -&gt; .NET Framework
            Ex: NET Framework -&gt; .NET Framework
            This includes self mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.TryConvertOrNormalize(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.String@)">
      <summary>
            Converts a key using the mappings, or if the key is already converted, finds the normalized form.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.GetAllEquivalentFrameworks(NuGet.Frameworks.NuGetFramework)">
      <summary>  
            Get all equivalent frameworks including the given framework  
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentProfiles(System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkSpecificMapping})">
      <summary>
            2 way per framework profile equivalence
            </summary>
      <param name="mappings">
      </param>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentFrameworks(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework}})">
      <summary>
            2 way framework equivalence
            </summary>
      <param name="mappings">
      </param>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkRange">
      <summary>
            An inclusive range of frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkRange.Satisfies(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework version falls between the min and max
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.Min">
      <summary>
            Minimum Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.Max">
      <summary>
            Maximum Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMin">
      <summary>
            Minimum version inclusiveness.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMax">
      <summary>
            Maximum version inclusiveness.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.FrameworkIdentifier">
      <summary>
            Framework Identifier of both the Min and Max
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkReducer">
      <summary>
            Reduces a list of frameworks into the smallest set of frameworks required.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor">
      <summary>
            Creates a FrameworkReducer using the default framework mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor(NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Creates a FrameworkReducer using custom framework mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.GetNearest(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Returns the nearest matching framework that is compatible.
            </summary>
      <param name="framework">Project target framework</param>
      <param name="possibleFrameworks">Possible frameworks to narrow down</param>
      <returns>Nearest compatible framework. If no frameworks are compatible null is returned.</returns>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceEquivalent(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Remove duplicates found in the equivalence mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceUpwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Reduce to the highest framework
            Ex: net45, net403, net40 -&gt; net45
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceDownwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Reduce to the lowest framework
            Ex: net45, net403, net40 -&gt; net40
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFrameworks(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Boolean)">
      <summary>
            Create lookup of the given PCLs to their actual frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFramework(NuGet.Frameworks.NuGetFramework,System.Boolean)">
      <summary>
            portable-net45+win8 -&gt; net45, win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.GetBestPCL(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Order PCLs when there is no other way to decide.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.IsBetterPCL(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Sort PCLs using these criteria
            1. Lowest number of frameworks (highest surface area) wins first
            2. Profile with the highest version numbers wins next
            3. String compare is used as a last resort
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkSpecificMapping">
      <summary>
            A keyvalue pair specific to a framework identifier
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFramework">
      <summary>
            A portable implementation of the .NET FrameworkName type with added support for NuGet folder names.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.Comparer">
      <summary>
            Full framework comparison of the identifier, version, profile, platform, and platform version
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.FrameworkNameComparer">
      <summary>
            Framework name only comparison.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework._packagesBased">
      <summary>
            Frameworks that are packages based across all versions.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.UnsupportedFramework">
      <summary>
            An unknown or invalid framework
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.AgnosticFramework">
      <summary>
            A framework with no specific target framework. This can be used for content only packages.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.AnyFramework">
      <summary>
            A wildcard matching all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetDotNetFrameworkName(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Formatted to a System.Versioning.FrameworkName
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName">
      <summary>
            Creates the shortened version of the framework using the default mappings.
            Ex: net45
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates the shortened version of the framework using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String)">
      <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFrameworkName(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a .NET FrameworkName
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String)">
      <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.TryParseDeprecatedFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
      <summary>
            Attempt to parse a common but deprecated framework using an exact string match
            Support for these should be dropped as soon as possible.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.TryParseCommonFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
      <summary>
            A set of special and common frameworks that can be returned from the list of constants without parsing
            Using the interned frameworks here optimizes comparisons since they can be checked by reference.
            This is designed to optimize
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Framework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Version">
      <summary>
            Target framework version
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.HasProfile">
      <summary>
            True if the profile is non-empty
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Profile">
      <summary>
            Target framework profile
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.DotNetFrameworkName">
      <summary>
            Formatted to a System.Versioning.FrameworkName
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsPCL">
      <summary>
            Portable class library check
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsPackageBased">
      <summary>
            True if the framework is packages based.
            Ex: dotnet, dnxcore, netcoreapp, netstandard, uap, netcore50
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.AllFrameworkVersions">
      <summary>
            True if this framework matches for all versions.
            Ex: net
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsUnsupported">
      <summary>
            True if this framework was invalid or unknown. This framework is only compatible with Any and Agnostic.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsAgnostic">
      <summary>
            True if this framework is non-specific. Always compatible.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsAny">
      <summary>
            True if this is the any framework. Always compatible.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsSpecificFramework">
      <summary>
            True if this framework is real and not one of the special identifiers.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
      <param name="selector">retrieves the framework from the group</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
      <param name="selector">retrieves the framework from the group</param>
      <param name="frameworkMappings">framework mappings</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsCompatibleWithFallbackCheck(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Check compatibility with additional checks for the fallback framework.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsNetCore50AndUp(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework is netcore50 or higher. This is where the framework
            becomes packages based.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.OneWayCompatibilityMappingEntry.#ctor(NuGet.Frameworks.FrameworkRange,NuGet.Frameworks.FrameworkRange)">
      <summary>
            Creates a one way compatibility mapping.
            Ex: net -supports-&gt; native
            </summary>
      <param name="targetFramework">Project framework</param>
      <param name="supportedFramework">Framework that is supported by the project framework</param>
    </member>
    <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.TargetFrameworkRange">
      <summary>
            Primary framework range or project target framework that supports the SuppportedFrameworkRange
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.SupportedFrameworkRange">
      <summary>
            Framework range that is supported by the TargetFrameworkRange
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.FrameworkMismatch">
      <summary>
              Looks up a localized string similar to Frameworks must have the same identifier, profile, and platform..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkIdentifier">
      <summary>
              Looks up a localized string similar to Invalid framework identifier '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkVersion">
      <summary>
              Looks up a localized string similar to Invalid framework version '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidPortableFrameworksDueToHyphen">
      <summary>
              Looks up a localized string similar to Invalid portable frameworks '{0}'. A hyphen may not be in any of the portable framework names..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.MissingPortableFrameworks">
      <summary>
              Looks up a localized string similar to Invalid portable frameworks for '{0}'. A portable framework must have at least one framework in the profile..
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel515559.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel515559.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.LibraryModel515559.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel515559.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependency.HasFlag(NuGet.LibraryModel.LibraryDependencyTypeFlag)">
      <summary>
            Type property flag
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependency.AutoReferenced">
      <summary>
            True if the PackageReference is added by the SDK and not the user.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryDependencyTarget.PackageProjectExternal">
      <summary>
            A package, project, or external project
            </summary>
    </member>
    <member name="T:NuGet.LibraryModel.LibraryDependencyTargetUtils">
      <summary>
            Helper methods for dealing with LibraryDependencyTarget strings.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyTargetUtils.Parse(System.String)">
      <summary>
            Convert flag string into a LibraryTypeFlag.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyTargetUtils.GetFlagString(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            Convert type flags to a friendly string.
            </summary>
    </member>
    <member name="T:NuGet.LibraryModel.LibraryIncludeFlagUtils">
      <summary>
            Helper methods for dealing with include/exclude flag strings.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryIncludeFlagUtils.DefaultSuppressParent">
      <summary>
            By default build, contentFiles, and analyzers do not flow transitively between projects.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlags(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Convert set of flag strings into a LibraryIncludeFlags.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlagString(NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Convert library flags to a friendly string.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlags(System.String,NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Convert set of flag strings into a LibraryIncludeFlags.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryRange.TypeConstraintAllows(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            True if the type constraint allows the flag.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryRange.TypeConstraintAllowsAnyOf(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            True if any flags are allowed by the constraint.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Project">
      <summary>
            Indicates that the library comes from compiling an XRE-based Project
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.ExternalProject">
      <summary>
            Indicates that the library comes from compiling an external project (such as an MSBuild-based project)
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Package">
      <summary>
            Indicates that the library comes from a NuGet Package
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Assembly">
      <summary>
            Indicates that the library comes from a stand-alone .NET Assembly
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Reference">
      <summary>
            Indicates that the library comes from a .NET Assembly in a globally-accessible
            location such as the GAC or the Framework Reference Assemblies
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.WinMD">
      <summary>
            Indicates that the library comes from a Windows Metadata Assembly (.winmd file)
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Unresolved">
      <summary>
            Indicates that the library could not be resolved
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core526779.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core526779.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Packaging.Core526779.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core526779.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Packaging.FrameworkSpecificGroup">
      <summary>
            A group of items/files from a nupkg with the same target framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FrameworkSpecificGroup.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Framework specific group
            </summary>
      <param name="targetFramework">group target framework</param>
      <param name="items">group items</param>
    </member>
    <member name="P:NuGet.Packaging.FrameworkSpecificGroup.TargetFramework">
      <summary>
            Group target framework
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FrameworkSpecificGroup.Items">
      <summary>
            Item relative paths
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageDependencyGroup">
      <summary>
            Package dependencies grouped to a target framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageDependencyGroup.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependency})">
      <summary>
            Dependency group
            </summary>
      <param name="targetFramework">target framework</param>
      <param name="packages">dependant packages</param>
    </member>
    <member name="P:NuGet.Packaging.PackageDependencyGroup.TargetFramework">
      <summary>
            Dependency group target framework
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageDependencyGroup.Packages">
      <summary>
            Package dependencies
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.IPackageIdentityComparer">
      <summary>
            Compares the id and version of a package
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Core.PackageDependencyComparer.Default">
      <summary>
            Default comparer
            Null ranges and the All range are treated as equal.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependencyInfoComparer.Default">
      <summary>
            Default comparer
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageIdentityComparer">
      <summary>
            Compares the Id, Version, and Version release label. Version build metadata is ignored.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor">
      <summary>
            Default version range comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Compare versions with a specific VersionComparison
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor(NuGet.Versioning.IVersionComparer)">
      <summary>
            Compare versions with a specific IVersionComparer
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.Equals(NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the package identities are the same when ignoring build metadata.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.GetHashCode(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Hash code of the id and version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.Compare(NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Compares on the Id first, then version
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentityComparer.Default">
      <summary>
            Default comparer that compares on the id, version, and version release labels.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.ContentFilesEntry">
      <summary>
            metadata/contentFiles/files entry from a nuspec
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Include">
      <summary>
            Included files
            </summary>
      <remarks>Required</remarks>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Exclude">
      <summary>
            Excluded files
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.BuildAction">
      <summary>
            Build action
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.CopyToOutput">
      <summary>
            If true the item will be copied to the output folder.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Flatten">
      <summary>
            If true the content items will keep the same folder structure in the output
            folder.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.ExtractPackageFileDelegate">
      <summary>
            Callback invoked to extract a package file.
            </summary>
      <param name="sourceFile">The path of the file in the package.</param>
      <param name="targetPath">The path to write to.</param>
      <param name="fileStream">The file <see cref="T:System.IO.Stream" />.</param>
      <returns>The file name if the file was written; otherwise <c>null</c>.</returns>
    </member>
    <member name="T:NuGet.Packaging.Core.INuspecCoreReader">
      <summary>
            A basic nuspec reader that understands ONLY the id, version, and min client version of a package.
            </summary>
      <remarks>Higher level concepts used for normal development nupkgs should go at a higher level</remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetId">
      <summary>
            Package Id
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetVersion">
      <summary>
            Package Version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetMinClientVersion">
      <summary>
            Minimum client version needed to consume the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetIdentity">
      <summary>
            Id and Version of a package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetMetadata">
      <summary>
            Package metadata in the nuspec
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.IPackageCoreReader">
      <summary>
            Basic package reader that provides the identity, min client version, and file access.
            </summary>
      <remarks>Higher level concepts used for normal development nupkgs should go at a higher level</remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetIdentity">
      <summary>
            Identity of the package
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetMinClientVersion">
      <summary>
            Minimum client version needed to consume the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetStream(System.String)">
      <summary>
            Returns a file stream from the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetFiles">
      <summary>
            All files in the nupkg
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetFiles(System.String)">
      <summary>
            Files in a folder
            </summary>
      <param name="folder">Folder path</param>
      <returns>A collection of files under specified folder</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetNuspec">
      <summary>
            Nuspec stream
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetNuspecFile">
      <summary>
            Nuspec path
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecCoreReader">
      <summary>
            A basic nuspec reader that understand id, version, and a flat list of dependencies.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.#ctor(System.IO.Stream)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Reads a nuspec from XML
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.GetDependencies">
      <summary>
            Returns a flat list of dependencies from a nuspec
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecCoreReaderBase">
      <summary>
            A very basic Nuspec reader that understands the Id, Version, PackageType, and MinClientVersion of a package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.String)">
      <summary>
            Read a nuspec from a path.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.IO.Stream)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Reads a nuspec from XML
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetId">
      <summary>
            Id of the package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetVersion">
      <summary>
            Version of the package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMinClientVersion">
      <summary>
            The minimum client version this package supports.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.IsServiceable">
      <summary>
            Returns if the package is serviceable.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetDevelopmentDependency">
      <summary>
            The developmentDependency attribute
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadata">
      <summary>
            Nuspec Metadata
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadataValue(System.String)">
      <summary>
            Returns a nuspec metadata value or string.Empty.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.NuspecCoreReaderBase.MetadataValues">
      <summary>
            Indexed metadata values of the XML elements in the nuspec.
            If duplicate keys exist only the first is used.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.NuspecCoreReaderBase.Xml">
      <summary>
            Raw XML doc
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecUtility">
      <summary>
            Until NuspecReader and Manifest are unified, this is a place to share implementations of
            reading and parsing specific elements out of the .nuspec XML.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecUtility.GetPackageTypes(System.Xml.Linq.XElement,System.Boolean)">
      <summary>
            Gets the package types from a .nuspec metadata XML element.
            </summary>
      <param name="metadataNode">The metadata XML element.</param>
      <param name="useMetadataNamespace">
            Whether or not to use the metadata element's namespace when finding the package type
            nodes. If false is specified, only the local names of the package type nodes are used
            for comparison. If true is specified, the package type nodes must have the same
            namespace as the metadata node.
            </param>
      <returns>
            A list of package types. If no package types are found in the metadata node, an empty
            list is returned.
            </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecUtility.IsServiceable(System.Xml.Linq.XElement)">
      <summary>
            Gets the value of serviceable element from a .nuspec metadata XML element.
            </summary>
      <param name="metadataNode">The metadata XML element.</param>
      <returns>
            true if the serviceable element is set in the .nuspec file as true, else false.
            </returns>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageDependency">
      <summary>
            Represents a package dependency Id and allowed version range.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependency.GetHashCode">
      <summary>
            Hash code from the default PackageDependencyComparer
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependency.ToString">
      <summary>
            Id and Version range string
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Id">
      <summary>
            Dependency package Id
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Include">
      <summary>
            Types to include from the dependency package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Exclude">
      <summary>
            Types to exclude from the dependency package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.VersionRange">
      <summary>
            Range of versions allowed for the depenency
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageDependencyInfo">
      <summary>
            Represents a package identity and the dependencies of a package.
            </summary>
      <remarks>
            This class does not support groups of dependencies, the group will need to be selected before
            populating this.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.#ctor(System.String,NuGet.Versioning.NuGetVersion,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependency})">
      <summary>
            Represents a package identity and the dependencies of a package.
            </summary>
      <param name="id">package name</param>
      <param name="version">package version</param>
      <param name="dependencies">package dependencies</param>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.GetHashCode">
      <summary>
            Hash code from the default PackageDependencyInfoComparer
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.ToString">
      <summary>
            Example: Id : Dependency1, Dependency2
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependencyInfo.Dependencies">
      <summary>
            Package dependencies
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageIdentity">
      <summary>
            Represents the core identity of a nupkg.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.#ctor(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a new package identity.
            </summary>
      <param name="id">name</param>
      <param name="version">version</param>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the package identities are the same.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity,NuGet.Versioning.VersionComparison)">
      <summary>
            True if the identity objects are equal based on the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.CompareTo(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Sorts based on the id, then version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(System.Object)">
      <summary>
            Compare using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.GetHashCode">
      <summary>
            Creates a hash code using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.ToString">
      <summary>
            PackageIdentity.ToString returns packageId.packageVersion"
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Id">
      <summary>
            Package name
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Version">
      <summary>
            Package Version
            </summary>
      <remarks>can be null</remarks>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.HasVersion">
      <summary>
            True if the version is non-null
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Comparer">
      <summary>
            An equality comparer that checks the id, version, and version release label.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Core.PackagingCoreConstants.EmptyFolder">
      <summary>
            _._ denotes an empty folder since OPC does not allow an
            actual empty folder.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Core.PackagingCoreConstants.ForwardSlashEmptyFolder">
      <summary>
            /_._ can be used to check empty folders from package readers where the / is normalized.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackagingException">
      <summary>
            Generic packaging exception.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.InvalidPackageTypeVersion">
      <summary>
              Looks up a localized string similar to Nuspec file contains a package type with an invalid package version '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingMetadataNode">
      <summary>
              Looks up a localized string similar to Nuspec file does not contain the '{0}' node..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingNuspec">
      <summary>
              Looks up a localized string similar to Nuspec file does not exist in package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingPackageTypeName">
      <summary>
              Looks up a localized string similar to Nuspec file contains a package type that is missing the name attribute..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MultipleNuspecFiles">
      <summary>
              Looks up a localized string similar to Package contains multiple nuspec files..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MultiplePackageTypes">
      <summary>
              Looks up a localized string similar to Nuspec file contains multiple package types. Zero or one package type nodes are allowed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to String argument '{0}' cannot be null or empty.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging540345.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging540345.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Packaging540345.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging540345.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.IObjectWriter">
      <summary>
            Provides functionality for writing an object graph.
            The output format is defined by implementors.
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteObjectStart(System.String)">
      <summary>
             Writes the start of a nested object.
            
             This new object becomes the scope for all other method calls until either WriteObjectStart
             is called again to start a new nested object or WriteObjectEnd is called.
            
             Every call to WriteObjectStart must be balanced by a corresponding call to WriteObjectEnd.
             </summary>
      <param name="name">The name of the object.  Throws if <c>null</c>.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteObjectEnd">
      <summary>
             Writes the end of a nested object.
            
             The parent object for this object becomes the scope for subsequent method calls.
             If this object is the root object, no further writing is allowed.
            
             Every call to WriteObjectStart must be balanced by a corresponding call to WriteObjectEnd.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.Int32)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.Boolean)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.String)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameArray(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Writes a name-collection pair.
            </summary>
      <param name="name">The name of the data.  Throws if <c>null</c>.</param>
      <param name="values">The data.</param>
    </member>
    <member name="T:NuGet.RuntimeModel.JsonObjectWriter">
      <summary>
             Generates JSON from an object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.GetJson">
      <summary>
             Gets the JSON for the object.
            
             Once <see cref="M:NuGet.RuntimeModel.JsonObjectWriter.GetJson" /> is called, no further writing is allowed.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.GetJObject">
      <summary>
            Gets the JObject (in-memory JSON model) for the object.
            
            Once <see cref="M:NuGet.RuntimeModel.JsonObjectWriter.GetJObject" /> is called, no further writing is allowed.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.WriteTo(Newtonsoft.Json.JsonTextWriter)">
      <summary>
             Writes the result to a <c>JsonTextWriter</c>.
            
             Once WriteTo is called, no further writing is allowed.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeDescription.Merge(NuGet.RuntimeModel.RuntimeDescription,NuGet.RuntimeModel.RuntimeDescription)">
      <summary>
            Merges the content of the other runtime description in to this runtime description
            </summary>
      <param name="other">The other description to merge in to this description</param>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.Merge(NuGet.RuntimeModel.RuntimeGraph,NuGet.RuntimeModel.RuntimeGraph)">
      <summary>
            Merges the content of the other runtime graph in to this runtime graph
            </summary>
      <param name="other">The other graph to merge in to this graph</param>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.AreCompatible(System.String,System.String)">
      <summary>
            Determines if two runtime identifiers are compatible, based on the import graph
            </summary>
      <param name="criteria">The criteria being tested</param>
      <param name="provided">The value the criteria is being tested against</param>
      <returns>
            true if an asset for the runtime in <paramref name="provided" /> can be installed in a project
            targetting <paramref name="criteria" />, false otherwise
            </returns>
    </member>
    <member name="T:NuGet.Packaging.INuspecReader">
      <summary>
            A development package nuspec reader
            </summary>
    </member>
    <member name="M:NuGet.Packaging.INuspecReader.GetLanguage">
      <summary>
            The locale ID for the package, such as en-us.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetFrameworkItems">
      <summary>
            Returns all framework references found in the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetBuildItems">
      <summary>
            Returns all items under the build folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetToolItems">
      <summary>
            Returns all items under the tools folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetContentItems">
      <summary>
            Returns all items found in the content folder.
            </summary>
      <remarks>
            Some legacy behavior has been dropped here due to the mix of content folders and target framework
            folders here.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetLibItems">
      <summary>
            Returns all lib items without any filtering. Use GetReferenceItems for the filtered list.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetReferenceItems">
      <summary>
            Returns lib items + filtering based on the nuspec and other NuGet rules.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetPackageDependencies">
      <summary>
            Returns package dependencies.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.IPackageResolver">
      <summary>
            Core package resolver
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">All relevant packages. This list must include the target packages.</param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">
            All relevant packages. This list must include the target packages and
            installed packages.
            </param>
      <param name="installedPackages">
            Packages already installed into the project. These will be favored as
            dependency options.
            </param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">All relevant packages. This list must include the target packages.</param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">
            All relevant packages. This list must include the target packages and
            installed packages.
            </param>
      <param name="installedPackages">
            Packages already installed into the project. These will be favored as
            dependency options.
            </param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="T:NuGet.Packaging.MinClientVersionException">
      <summary>
            Custom exception type for a package that has a higher minClientVersion than the current client.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.PathResolver">
      <summary>
            Path resolver for the root package folder containing this package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.Id">
      <summary>
            Package id.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.Version">
      <summary>
            Package version.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.#ctor(NuGet.Common.INuGetPathContext)">
      <summary>
            Creates a package folder path resolver that scans multiple folders to find a package.
            </summary>
      <param name="pathContext">NuGet paths loaded from NuGet.Config settings.</param>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(System.String,System.String)">
      <summary>
            Returns the root directory of an installed package.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the path if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Returns the root directory of an installed package.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the path if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageInfo(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Returns the package info along with a path resolver specific to the folder where the package exists.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the package info if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="T:NuGet.Packaging.MinClientVersionUtility">
      <summary>
            Helpers for dealing with the NuGet client version and package minClientVersions.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.VerifyMinClientVersion(NuGet.Packaging.Core.NuspecCoreReaderBase)">
      <summary>
            Check the package minClientVersion and throw if it is greater than the current client version.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Packaging.Core.NuspecCoreReaderBase)">
      <summary>
            Verify minClientVersion.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Versioning.NuGetVersion)">
      <summary>
            Verify minClientVersion.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.GetNuGetClientVersion">
      <summary>
            Read the NuGet client version from the assembly info as a NuGetVersion.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.NuspecReader">
      <summary>
            Reads .nuspec files
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.String)">
      <summary>
            Nuspec file reader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Nuspec file reader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.IO.Stream)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="stream">Nuspec file stream.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="xml">Nuspec file xml data.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.IO.Stream,NuGet.Frameworks.IFrameworkNameProvider,System.Boolean)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="stream">Nuspec file stream.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.Xml.Linq.XDocument,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="xml">Nuspec file xml data.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDependencyGroups">
      <summary>
            Read package dependencies for all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDependencyGroups(System.Boolean)">
      <summary>
            Read package dependencies for all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetReferenceGroups">
      <summary>
            Reference item groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetFrameworkReferenceGroups">
      <summary>
            Framework reference groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetLanguage">
      <summary>
            Package language
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetLicenseUrl">
      <summary>
            Package License Url
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetContentFiles">
      <summary>
            Build action groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetTitle">
      <summary>
            Package title.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetAuthors">
      <summary>
            Package authors.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetTags">
      <summary>
            Package tags.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetOwners">
      <summary>
            Package owners.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDescription">
      <summary>
            Package description.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetReleaseNotes">
      <summary>
            Package release notes.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetSummary">
      <summary>
            Package summary.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetProjectUrl">
      <summary>
            Package project url.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetIconUrl">
      <summary>
            Package icon url.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetCopyright">
      <summary>
            Copyright information.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetRequireLicenseAcceptance">
      <summary>
            Require license acceptance when installing the package.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageArchiveReader">
      <summary>
            Reads a development nupkg
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="leaveStreamOpen">If true the nupkg stream will not be closed by the zip reader.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="leaveStreamOpen">leave nupkg stream open</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Compression.ZipArchive)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="zipArchive">ZipArchive containing the nupkg data.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Compression.ZipArchive,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="zipArchive">ZipArchive containing the nupkg data.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="T:NuGet.Packaging.EmptyFrameworkFolderFile">
      <summary>
            Represents an empty framework folder in NuGet 2.0+ packages. 
            An empty framework folder is represented by a file named "_._".
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageFile.Path">
      <summary>
            Gets the full path of the file inside the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageFile.EffectivePath">
      <summary>
            Gets the path that excludes the root folder (content/lib/tools) and framework folder (if present).
            </summary>
      <example>
            If a package has the Path as 'content\[net40]\scripts\jQuery.js', the EffectivePath 
            will be 'scripts\jQuery.js'.
            
            If it is 'tools\init.ps1', the EffectivePath will be 'init.ps1'.
            </example>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.FrameworkReferences">
      <summary>
            Specifies assemblies from GAC that the package depends on.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences">
      <summary>
            Returns sets of References specified in the manifest.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.DependencyGroups">
      <summary>
            Specifies sets other packages that the package depends on.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.ContentFiles">
      <summary>
            Returns sets of Content Files specified in the manifest.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Manifest.Save(System.IO.Stream)">
      <summary>
            Saves the current manifest to the specified stream.
            </summary>
      <param name="stream">The target stream.</param>
    </member>
    <member name="M:NuGet.Packaging.Manifest.Save(System.IO.Stream,System.Int32)">
      <summary>
            Saves the current manifest to the specified stream.
            </summary>
      <param name="stream">The target stream.</param>
      <param name="minimumManifestVersion">The minimum manifest version that this class must use when saving.</param>
    </member>
    <member name="M:NuGet.Packaging.ManifestMetadata.#ctor(NuGet.Packaging.IPackageMetadata)">
      <summary>
            Constructs a ManifestMetadata instance from an IPackageMetadata instance
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV1">
      <summary>
            Baseline schema 
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV2">
      <summary>
            Added copyrights, references and release notes
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV3">
      <summary>
            Used if the version is a semantic version.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV4">
      <summary>
            Added 'targetFramework' attribute for 'dependency' elements.
            Allow framework folders under 'content' and 'tools' folders. 
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV5">
      <summary>
            Added 'targetFramework' attribute for 'references' elements.
            Added 'minClientVersion' attribute
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV6">
      <summary>
            Allows XDT transformation
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.ResolvePackagePath(System.String,System.String,System.String,System.String)">
      <summary>
            Determins the path of the file inside a package.
            For recursive wildcard paths, we preserve the path portion beginning with the wildcard.
            For non-recursive wildcard paths, we use the file name from the actual file path on disk.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.IsKnownFolder(System.String)">
      <summary>
            Returns true if the path uses a known folder root.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.ParseTags(System.String)">
      <summary>
            Tags come in this format. tag1 tag2 tag3 etc..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageBuilder.Properties">
      <summary>
            Exposes the additional properties extracted by the metadata 
            extractor or received from the command line.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageBuilder.ContentFiles">
      <summary>
            ContentFiles section from the manifest for content v2
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="targetFramework">The target framework to use, pass Any for AnyFramework. Does not allow null.</param>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="targetFramework">The target framework to use.</param>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="P:NuGet.Packaging.PhysicalPackageFile.SourcePath">
      <summary>
            Path on disk
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PhysicalPackageFile.TargetPath">
      <summary>
            Path in package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FrameworkNameUtility.ParseFrameworkFolderName(System.String,System.Boolean,System.String@)">
      <summary>
            Parses the specified string into FrameworkName object.
            </summary>
      <param name="path">The string to be parse.</param>
      <param name="strictParsing">if set to <c>true</c>, parse the first folder of path even if it is unrecognized framework.</param>
      <param name="effectivePath">returns the path after the parsed target framework</param>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.PackageExtractionContext.UseLegacyPackageInstallPath">
      <summary>
            If True package folder paths will use the non-normalized version path,
            even for new installs.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageHelper.IsSatellitePackage(NuGet.Packaging.Core.IPackageCoreReader,NuGet.Packaging.Core.PackageIdentity@,System.String@)">
      <summary>
            A package is deemed to be a satellite package if it has a language property set, the id of the package is
            of the format [.*].[Language]
            and it has at least one dependency with an id that maps to the runtime package .
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageHelper.GetInstalledPackageFiles(NuGet.Packaging.PackageArchiveReader,NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.PackagePathResolver,NuGet.Packaging.PackageSaveMode)">
      <summary>
            This returns all the installed package files (does not include satellite files)
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackageSaveMode.Defaultv2">
      <summary>
            Default package save mode for v2 (packages.config)-style restore.
            This includes <see cref="F:NuGet.Packaging.PackageSaveMode.Files" /> and <see cref="F:NuGet.Packaging.PackageSaveMode.Nupkg" />.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackageSaveMode.Defaultv3">
      <summary>
            Default package save mode for v3 (project.json)-style restore.
            This includes <see cref="F:NuGet.Packaging.PackageSaveMode.Files" />, <see cref="F:NuGet.Packaging.PackageSaveMode.Nuspec" />, and <see cref="F:NuGet.Packaging.PackageSaveMode.Nupkg" />.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.None">
      <summary>
            Treat XML doc files as regular files (legacy behavior).
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.Skip">
      <summary>
            Do not extract XML documentation files
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.Compress">
      <summary>
            Compress XML doc files in a zip archive.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.ZipArchiveExtensions">
      <summary>
            Nupkg reading helper methods
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageExtractor.InstallFromSourceAsync(System.Func{System.IO.Stream,System.Threading.Tasks.Task},NuGet.Packaging.VersionFolderPathContext,System.Threading.CancellationToken)">
      <summary>
            Uses a copy function to install a package to a global packages directory.
            </summary>
      <param name="copyToAsync">
            A function which should copy the package to the provided destination stream.
            </param>
      <param name="versionFolderPathContext">
            The version folder path context, which encapsulates all of the parameters to observe
            while installing the package.
            </param>
      <param name="token">The cancellation token.</param>
      <returns>
            True if the package was installed. False if the package already exists and therefore
            resulted in no copy operation.
            </returns>
    </member>
    <member name="T:NuGet.Packaging.PackageFolderReader">
      <summary>
            Reads an unzipped nupkg folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.String)">
      <summary>
            Package folder reader
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.IO.DirectoryInfo)">
      <summary>
            Package folder reader
            </summary>
      <param name="folder">root directory of an extracted nupkg</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.String,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Package folder reader
            </summary>
      <param name="folderPath">root directory of an extracted nupkg</param>
      <param name="frameworkProvider">framework mappings</param>
      <param name="compatibilityProvider">framework compatibility provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.IO.DirectoryInfo,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Package folder reader
            </summary>
      <param name="folder">root directory of an extracted nupkg</param>
      <param name="frameworkProvider">framework mappings</param>
      <param name="compatibilityProvider">framework compatibility provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.GetStream(System.String)">
      <summary>
            Opens a local file in read only mode.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.GetRelativePath(System.IO.DirectoryInfo,System.IO.FileInfo)">
      <summary>
            Build the relative path in the same format that ZipArchive uses
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageReaderBase">
      <summary>
            Abstract class that both the zip and folder package readers extend
            This class contains the path conventions for both zip and folder readers
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.#ctor(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Core package reader
            </summary>
      <param name="frameworkProvider">framework mapping provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.#ctor(NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Core package reader
            </summary>
      <param name="frameworkProvider">framework mapping provider</param>
      <param name="compatibilityProvider">framework compatibility provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.GetSupportedFrameworks">
      <summary>
            Frameworks mentioned in the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.IsAllowedBuildFile(System.String,System.String)">
      <summary>
            only packageId.targets and packageId.props should be used from the build folder
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.IsReferenceAssembly(System.String)">
      <summary>
            True only for assemblies that should be added as references to msbuild projects
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReaderBase.NuspecReader">
      <summary>
            Nuspec reader
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageReference">
      <summary>
            Represents a package element in the packages.config file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean,System.Boolean,System.Boolean,NuGet.Versioning.VersionRange)">
      <summary>
            Creates a new packages config entry
            </summary>
      <param name="identity">Package id and version</param>
      <param name="targetFramework">Package target framework installed to the project</param>
      <param name="userInstalled">True if the user installed this package directly</param>
      <param name="developmentDependency">True if the package is a development dependency</param>
      <param name="requireReinstallation">True if this package needs to be reinstalled</param>
      <param name="allowedVersions">Restrict package versions to the allowedVersions range</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.ToString">
      <summary>
            Displays the identity and target framework of the reference.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.PackageIdentity">
      <summary>
            Id and Version of the package
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.AllowedVersions">
      <summary>
            The allowed range of versions that this package can be upgraded/downgraded to.
            </summary>
      <remarks>This is null if unbounded</remarks>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.HasAllowedVersions">
      <summary>
            True if allowedVersions exists.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.TargetFramework">
      <summary>
            Installed target framework version of the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.IsDevelopmentDependency">
      <summary>
            Development dependency
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.IsUserInstalled">
      <summary>
            True if the user installed or updated this package directly.
            False if this package was installed as a dependency by another package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.RequireReinstallation">
      <summary>
            Require reinstallation
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfig.HasAttributeValue(System.Xml.Linq.XElement,System.String,System.String,System.Xml.Linq.XElement@)">
      <summary>
            Determine if the package node has the attribute value as the targetValue.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfig.BoolAttribute(System.Xml.Linq.XElement,System.String,System.Boolean)">
      <summary>
            Get a boolean attribute value, or false if it does not exist
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackagesConfigReader">
      <summary>
            Reads packages.config
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Packages.config reader
            </summary>
      <param name="xml">Packages.config XML</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(NuGet.Frameworks.IFrameworkNameProvider,System.Xml.Linq.XDocument)">
      <summary>
            Packages.config reader
            </summary>
      <param name="frameworkMappings">Additional target framework mappings for parsing target frameworks</param>
      <param name="xml">Packages.config XML</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.IO.Stream)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
      <param name="leaveStreamOpen">True will leave the stream open</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(NuGet.Frameworks.IFrameworkNameProvider,System.IO.Stream,System.Boolean)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
      <param name="leaveStreamOpen">True will leave the stream open</param>
      <param name="frameworkMappings">Additional target framework mappings for parsing target frameworks</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetMinClientVersion">
      <summary>
            Reads the minimum client version from packages.config
            </summary>
      <returns>Minimum client version or the default of 2.5.0</returns>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetPackages">
      <summary>
            Reads all package node entries in the config.
            If duplicate package ids exist an exception will be thrown.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetPackages(System.Boolean)">
      <summary>
            Reads all package node entries in the config.
            </summary>
      <param name="allowDuplicatePackageIds">If True validation will be performed to ensure that 
            only one entry exists for each unique package id.</param>
    </member>
    <member name="T:NuGet.Packaging.PackagesConfigWriter">
      <summary>
            Writes the packages.config XML file to a stream
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.String,System.Boolean)">
      <summary>
            Create a packages.config writer using file path
            </summary>
      <param name="fullPath">The full path to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.String,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Create a packages.config writer using file path
            </summary>
      <param name="fullPath">The full path to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
      <param name="frameworkMappings">Framework mappings</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Create a packages.config writer using stream
            </summary>
      <param name="stream">Stream to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.IO.Stream,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Create a packages.config writer using stream
            </summary>
      <param name="stream">Stream to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
      <param name="frameworkMappings">Framework mappings</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.WriteMinClientVersion(NuGet.Versioning.NuGetVersion)">
      <summary>
            Write a minimum client version to packages.config
            </summary>
      <param name="version">Minumum version of the client required to parse and use this file.</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Add a package entry
            </summary>
      <param name="packageId">Package Id</param>
      <param name="version">Package Version</param>
      <param name="targetFramework">Package targetFramework that's compatible with current project</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Adds a basic package entry to the file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.PackageReference)">
      <summary>
            Adds a package entry to the file
            </summary>
      <param name="entry">Package reference entry</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.UpdatePackageEntry(NuGet.Packaging.PackageReference,NuGet.Packaging.PackageReference)">
      <summary>
            Update a package entry to the file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.UpdateOrAddPackageEntry(System.Xml.Linq.XDocument,NuGet.Packaging.PackageReference)">
      <summary>
            Update a package entry using the original entry as a base if it exists.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Remove a package entry
            </summary>
      <param name="packageId">Package Id</param>
      <param name="version">Package version</param>
      <param name="targetFramework">Package targetFramework</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Remove a package identity from the file
            </summary>
      <param name="identity">Package identity</param>
      <param name="targetFramework">Package targetFramework</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.PackageReference)">
      <summary>
            Removes a package entry from the file
            </summary>
      <param name="entry">Package reference entry</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.WriteFile(System.String)">
      <summary>
            Write the XDocument to the packages.config and disallow further changes.
            </summary>
      <param name="fullPath">the full path to packages.config file</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.Dispose">
      <summary>
            Write the XDocument to the stream and close it to disallow further changes.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackagingConstants.ManifestExtension">
      <summary>
            Represents the ".nuspec" extension.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Unsupported targetFramework value '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorDuplicatePackages">
      <summary>
              Looks up a localized string similar to There are duplicate packages: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidAllowedVersions">
      <summary>
              Looks up a localized string similar to Invalid allowedVersions for package id '{0}': '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidMinClientVersion">
      <summary>
              Looks up a localized string similar to Invalid minClientVersion: '{0}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidPackageVersion">
      <summary>
              Looks up a localized string similar to Invalid package version for package id '{0}': '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidPackageVersionForDependency">
      <summary>
              Looks up a localized string similar to Invalid package version for a dependency with id '{0}' in package '{1}': '{2}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorNullOrEmptyPackageId">
      <summary>
              Looks up a localized string similar to Null or empty package id.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorUnableToDeleteFile">
      <summary>
              Looks up a localized string similar to Unable to delete temporary file '{0}'. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailedFileTime">
      <summary>
              Looks up a localized string similar to Failed to update file time for {0}: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailToLoadPackagesConfig">
      <summary>
              Looks up a localized string similar to Fail to load packages.config as XML file. Please check it. .
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailToWritePackagesConfig">
      <summary>
              Looks up a localized string similar to Failed to write packages.config as XML file '{0}'. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FallbackFolderNotFound">
      <summary>
              Looks up a localized string similar to Unable to find fallback package folder '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidNuspecElement">
      <summary>
              Looks up a localized string similar to {0} This validation error occurred in a '{1}' element..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidNuspecEntry">
      <summary>
              Looks up a localized string similar to The nuspec contains an invalid entry '{0}' in package '{1}' ..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageFrameworkFolderName">
      <summary>
              Looks up a localized string similar to The framework in the folder name of '{0}' in package '{1}' could not be parsed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Log_InstallingPackage">
      <summary>
              Looks up a localized string similar to Installing {0} {1}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MinClientVersionAlreadyExist">
      <summary>
              Looks up a localized string similar to MinClientVersion already exists in packages.config.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MissingNuspec">
      <summary>
              Looks up a localized string similar to Nuspec file does not exist in package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MultipleNuspecFiles">
      <summary>
              Looks up a localized string similar to Package contains multiple nuspec files..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MustContainAbsolutePath">
      <summary>
              Looks up a localized string similar to '{0}' must contain an absolute path '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageEntryAlreadyExist">
      <summary>
              Looks up a localized string similar to Package entry already exists in packages.config. Id: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageEntryNotExist">
      <summary>
              Looks up a localized string similar to Package entry does not exists in packages.config. Id: {0}, Version: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageMinVersionNotSatisfied">
      <summary>
              Looks up a localized string similar to The '{0}' package requires NuGet client version '{1}' or above, but the current NuGet version is '{2}'. To upgrade NuGet, please go to http://docs.nuget.org/consume/installing-nuget.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackagesNodeNotExist">
      <summary>
              Looks up a localized string similar to Packages node does not exists in packages.config at {0}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageStreamShouldBeSeekable">
      <summary>
              Looks up a localized string similar to Package stream should be seekable.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to String argument '{0}' cannot be null or empty.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnableToAddEntry">
      <summary>
              Looks up a localized string similar to An error occurred while updating packages.config. The file was closed before the entry could be added..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnableToParseClientVersion">
      <summary>
              Looks up a localized string similar to Unable to parse the current NuGet client version..
            </summary>
    </member>
    <member name="M:NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo})">
      <summary>
            Order dependencies by children first.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.#ctor(System.String)">
      <summary>
            VersionFolderPathResolver
            </summary>
      <param name="rootPath">Packages directory root folder.</param>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.#ctor(System.String,System.Boolean)">
      <summary>
            VersionFolderPathResolver
            </summary>
      <param name="rootPath">Packages directory root folder.</param>
      <param name="isLowercase">True if package id and versions are made lowercase.</param>
    </member>
    <member name="P:NuGet.Packaging.VersionFolderPathResolver.RootPath">
      <summary>
            Packages directory root folder.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.VersionFolderPathResolver.IsLowerCase">
      <summary>
            True if package id and versions are made lowercase.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageExtraction.PackageExtractionBehavior.XmlDocFileSaveMode">
      <summary>
            Gets or sets the <see cref="!:PackageExtraction.XmlDocFileSaveMode" />.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageCreation.Resources.NuGetResources">
      <summary>
               A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.ResourceManager">
      <summary>
               Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Culture">
      <summary>
               Overrides the current thread's CurrentUICulture property for all
               resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.CannotCreateEmptyPackage">
      <summary>
               Looks up a localized string similar to Cannot create a package that has no dependencies nor content..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.DependencyHasInvalidVersion">
      <summary>
               Looks up a localized string similar to Dependency '{0}' has an invalid version..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.DuplicateDependenciesDefined">
      <summary>
               Looks up a localized string similar to '{0}' already has a dependency defined for '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.IncompatibleSchema">
      <summary>
               Looks up a localized string similar to The schema version of '{0}' is incompatible with version {1} of NuGet. Please upgrade NuGet to the latest version from http://go.microsoft.com/fwlink/?LinkId=213942..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.InvalidPackageId">
      <summary>
               Looks up a localized string similar to The package ID '{0}' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_DependenciesHasMixedElements">
      <summary>
               Looks up a localized string similar to &lt;dependencies&gt; element must not contain both &lt;group&gt; and &lt;dependency&gt; child elements..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ExcludeContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Exclude path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_IdMaxLengthExceeded">
      <summary>
               Looks up a localized string similar to Id must not exceed 100 characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidMinClientVersion">
      <summary>
               Looks up a localized string similar to The 'minClientVersion' attribute in the package manifest has invalid value. It must be a valid version string..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidReference">
      <summary>
               Looks up a localized string similar to Invalid assembly reference '{0}'. Ensure that a file named '{0}' exists in the lib directory..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidReferenceFile">
      <summary>
               Looks up a localized string similar to Assembly reference '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ReferencesHasMixedElements">
      <summary>
               Looks up a localized string similar to &lt;references&gt; element must not contain both &lt;group&gt; and &lt;reference&gt; child elements..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ReferencesIsEmpty">
      <summary>
               Looks up a localized string similar to The element package\metadata\references\group must contain at least one &lt;reference&gt; child element..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequiredElementMissing">
      <summary>
               Looks up a localized string similar to The required element '{0}' is missing from the manifest..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequiredMetadataMissing">
      <summary>
               Looks up a localized string similar to {0} is required..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequireLicenseAcceptanceRequiresLicenseUrl">
      <summary>
               Looks up a localized string similar to Enabling license acceptance requires a license url..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_SourceContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Source path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_TargetContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Target path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_UriCannotBeEmpty">
      <summary>
               Looks up a localized string similar to {0} cannot be empty..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.PackageAuthoring_FileNotFound">
      <summary>
               Looks up a localized string similar to File not found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.UnknownSchemaVersion">
      <summary>
               Looks up a localized string similar to Unknown schema version '{0}'..
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.ContentPropertyDefinition">
      <summary>
            Defines a property that can be used in Content Model query patterns
            <seealso cref="T:NuGet.ContentModel.PatternSet" /></summary>
    </member>
    <member name="P:NuGet.ContentModel.ContentPropertyDefinition.CompareTest">
      <summary>
            Find the nearest compatible candidate.
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternSet">
      <summary>
            A set of patterns that can be used to query a set of file paths for items matching a provided criteria.
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.GroupPatterns">
      <summary>
            Patterns used to select a group of items that matches the criteria
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.PathPatterns">
      <summary>
            Patterns used to select individual items that match the criteria
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.PropertyDefinitions">
      <summary>
            Property definitions used for matching patterns
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternDefinition">
      <summary>
            A pattern that can be used to match file paths given a provided criteria.
            </summary>
      <remarks>
            The pattern is defined as a sequence of literal path strings that must match exactly and property
            references,
            wrapped in {} characters, which are tested for compatibility with the consumer-provided criteria.
            <seealso cref="T:NuGet.ContentModel.ContentPropertyDefinition" /></remarks>
    </member>
    <member name="P:NuGet.ContentModel.PatternDefinition.Table">
      <summary>
            Replacement token table.
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternTable">
      <summary>
            Replacement token table organized by property.
            </summary>
    </member>
    <member name="M:NuGet.ContentModel.PatternTable.TryLookup(System.String,System.String,System.Object@)">
      <summary>
            Lookup a token and get the replacement if it exists.
            </summary>
      <param name="propertyName">Property moniker</param>
      <param name="name">Token name</param>
      <param name="value">Replacement value</param>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.PropertyName">
      <summary>
            PropertyName moniker
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.Name">
      <summary>
            Item name
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.Value">
      <summary>
            Item replacement value
            </summary>
    </member>
    <member name="T:NuGet.Client.AnyFramework">
      <summary>
            An internal NuGetFramework marker for ManagedCodeConventions.
            Most conventions disallow the string 'any' as a txm, so to allow
            it for conventions with no txm in the path we use this special type.
            </summary>
    </member>
    <member name="T:NuGet.Client.ManagedCodeConventions">
      <summary>
            Defines all the package conventions used by Managed Code packages
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.AnyTargettedFile">
      <summary>
            Pattern used to locate all files targetted at a specific runtime and/or framework
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.RuntimeAssemblies">
      <summary>
            Pattern used to locate all files designed for loading as managed code assemblies at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileRefAssemblies">
      <summary>
            Pattern used to locate ref assemblies for compile.
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileLibAssemblies">
      <summary>
            Pattern used to locate lib assemblies for compile.
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.NativeLibraries">
      <summary>
            Pattern used to locate all files designed for loading as native code libraries at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ResourceAssemblies">
      <summary>
            Pattern used to locate all files designed for loading as managed code resource assemblies at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildFiles">
      <summary>
            Pattern used to identify MSBuild targets and props files
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildMultiTargetingFiles">
      <summary>
            Pattern used to identify MSBuild global targets and props files
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ContentFiles">
      <summary>
            Pattern used to identify content files
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel624631.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel624631.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.ProjectModel624631.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel624631.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.CircularMemoryStream">
      <summary>
            A circular memory stream backed by a fixed-size byte buffer.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetClosure(System.String)">
      <summary>
            Retrieve the full project closure including the root project itself.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.PackageSpec})">
      <summary>
            Order dependencies by children first.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Restore">
      <summary>
            Projects to restore.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Projects">
      <summary>
            All project specs.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Json">
      <summary>
            File json.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.ExternalProjectReference">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,NuGet.ProjectModel.PackageSpec,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
      <param name="uniqueName">unique project name or full path</param>
      <param name="packageSpec">project.json package spec.</param>
      <param name="msbuildProjectPath">project file if one exists</param>
      <param name="projectReferences">unique names of the referenced projects</param>
    </member>
    <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
      <param name="uniqueName">unique project name or full path</param>
      <param name="packageSpecPath">project.json file path or null if none exists</param>
      <param name="msbuildProjectPath">project file if one exists</param>
      <param name="projectReferences">unique names of the referenced projects</param>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.UniqueName">
      <summary>
            Unique name of the external project
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpec">
      <summary>
            The path to the project.json file representing the NuGet dependencies of the project
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ExternalProjectReferences">
      <summary>
            A list of other external projects this project references. Uses the UniqueName.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.MSBuildProjectPath">
      <summary>
            Path to msbuild project file. Ex: xproj, csproj
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectJsonPath">
      <summary>
            Path to project.json
            </summary>
      <remarks>This may be null for projects that do not contain project.json.</remarks>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpecProjectName">
      <summary>
            Project name used for project.json
            </summary>
      <remarks>This may be null for projects that do not contain project.json.</remarks>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectName">
      <summary>
            Project name from the package spec or msbuild file.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.HashObjectWriter">
      <summary>
             Generates a hash from an object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
    </member>
    <member name="M:NuGet.ProjectModel.HashObjectWriter.#ctor(NuGet.ProjectModel.IHashFunction)">
      <summary>
            Creates a new instance with the provide hash function.
            </summary>
      <param name="hashFunc">An <see cref="T:NuGet.ProjectModel.IHashFunction" /> instance.  Throws if <c>null</c>.</param>
    </member>
    <member name="M:NuGet.ProjectModel.HashObjectWriter.GetHash">
      <summary>
             Gets the hash for the object.
            
             Once GetHash is called, no further writing is allowed.
             </summary>
      <returns>A hash of the object.</returns>
    </member>
    <member name="T:NuGet.ProjectModel.IExternalProjectReferenceProvider">
      <summary>
            Provides external project reference closures.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetReferences(System.String)">
      <summary>
            Get the full p2p closure from an msbuild project path.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetEntryPoints">
      <summary>
            Returns all known entry points.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.IHashFunction">
      <summary>
            Provides incremental hashing.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IHashFunction.GetHash">
      <summary>
             Gets the hash.
            
             Once GetHash is called, no further hash updates are allowed.
             </summary>
      <returns>A base64-encoded hash.</returns>
    </member>
    <member name="M:NuGet.ProjectModel.IHashFunction.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Incrementally updates the hash.
            </summary>
      <param name="data">The data to be included in the hash.</param>
      <param name="offset">The offset from which data should be read.</param>
      <param name="count">The count of bytes to read.</param>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetPackageSpec(System.String,System.String)">
      <summary>
            Load and parse a project.json file
            </summary>
      <param name="name">project name</param>
      <param name="packageSpecPath">file path</param>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetBoolOrFalse(Newtonsoft.Json.Linq.JToken,System.String,System.String)">
      <summary>
            Returns true if the property is set to true. Otherwise false.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetBoolOrFalse(Newtonsoft.Json.Linq.JObject,System.String,System.String)">
      <summary>
            Returns true if the property is set to true. Otherwise false.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileLibrary.Clone">
      <summary>
            Makes a deep clone of the lock file library.
            </summary>
      <returns>The cloned lock file library.</returns>
    </member>
    <member name="P:NuGet.ProjectModel.LockFileLibrary.Path">
      <summary>
            Relative path to the project.json file for projects
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.LockFileLibrary.MSBuildProject">
      <summary>
            Relative path to the msbuild project file. Ex: xproj, csproj
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileUtilities.GetLockFile(System.String,NuGet.Common.ILogger)">
      <summary>
            Returns the lockfile if it exists, otherwise null.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpec">
      <summary>
            Represents the specification of a package that can be built.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpec.Clone">
      <summary>
            Clone a PackageSpec and underlying JObject.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.PackageSpec.RestoreMetadata">
      <summary>
            Additional MSBuild properties.
            </summary>
      <remarks>Optional. This is normally set for internal use only.</remarks>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetTargetFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get the nearest framework available in the project.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetRestoreMetadataFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get restore metadata framework. This is based on the project's target frameworks, then an 
            exact match is found under restore metadata.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecOperations.GetDependencyLists(NuGet.ProjectModel.PackageSpec,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Boolean)">
      <summary>
            Get the list of dependencies in the package spec. Unless null is provided, the
            <paramref name="frameworksToConsider" /> set can be used to get the dependency lists for only for the
            provided target frameworks. If null is provided, all framework dependency lists are returned.
            </summary>
      <param name="spec">The package spec.</param>
      <param name="includeGenericDependencies">
            Whether or not the generic dependency list should be returned (dependencies that apply to all target
            frameworks.
            </param>
      <param name="frameworksToConsider">The frameworks to consider.</param>
      <returns>The sequence of dependency lists.</returns>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider">
      <summary>
            Handles both external references and projects discovered through directories
            If the type is set to external project directory discovery will be disabled.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetDependenciesFromSpecRestoreMetadata(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            .NETCore projects
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetDependenciesFromExternalReference(NuGet.ProjectModel.ExternalProjectReference,NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            UWP Project.json
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetProjectNames(System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
      <summary>
            Filter dependencies down to only possible project references and return the names.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecUtility.SpecifySnapshot(System.String,System.String)">
      <summary>
            Apply a snapshot value.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecUtility.IsSnapshotVersion(System.String)">
      <summary>
            True if the string is a snapshot version.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpecWriter">
      <summary>
            Writes out a PackageSpec object graph.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.Write(NuGet.ProjectModel.PackageSpec,NuGet.RuntimeModel.IObjectWriter)">
      <summary>
            Writes a PackageSpec to an <c>NuGet.Common.IObjectWriter</c> instance. 
            </summary>
      <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
      <param name="writer">An <c>NuGet.Common.IObjectWriter</c> instance.</param>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.WriteToFile(NuGet.ProjectModel.PackageSpec,System.String)">
      <summary>
            Writes a PackageSpec to a file.
            </summary>
      <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
      <param name="filePath">A file path to write to.</param>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectStyle">
      <summary>
            Restore behavior type.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectPath">
      <summary>
            MSBuild project file path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectJsonPath">
      <summary>
            Full path to the project.json file if it exists.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OutputPath">
      <summary>
            Assets file output path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectName">
      <summary>
            Friendly project name.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectUniqueName">
      <summary>
            Name unique to the project across the solution.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Sources">
      <summary>
            Package feed sources.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.PackagesPath">
      <summary>
            User packages folder path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.FallbackFolders">
      <summary>
            Fallback folders.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.TargetFrameworks">
      <summary>
            Framework specific metadata, this may be a subset of the project's frameworks.
            Operations to determine the nearest framework should be done against the project's frameworks, 
            and then matched directly to this section.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OriginalTargetFrameworks">
      <summary>
            Original target frameworks strings. These are used to match msbuild conditionals to $(TargetFramework)
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CrossTargeting">
      <summary>
            True if $(TargetFrameworks) is used and the build is using Cross Targeting.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.LegacyPackagesDirectory">
      <summary>
            Whether or not to restore the packages directory using the legacy format, which write original case paths
            instead of lowercase.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Files">
      <summary>
            Asset files. These should be equivalent to the files that would be
            in the nupkg after packing the project.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ValidateRuntimeAssets">
      <summary>
            Compatibility check for runtime framework assets.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.SkipContentFileWrite">
      <summary>
            True if this is an XPlat PackageReference project.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.PackagePath">
      <summary>
            Relative path that would be used within a package.
            This will be used to determine the asset type.
            Example: lib/net45/a.dll
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.AbsolutePath">
      <summary>
            Absolute path on disk.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.FrameworkName">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.OriginalFrameworkName">
      <summary>
            The original string before parsing the framework name. In some cases, it is important to keep this around
            because MSBuild framework conditions require the framework name to be the original string (non-normalized).
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.ProjectReferences">
      <summary>
            Project references
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectUniqueName">
      <summary>
            Project unique name.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectPath">
      <summary>
            Full path to the msbuild project file.
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.Unknown">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.ProjectJson">
      <summary>
            UAP style, project.lock.json is generated next to project.json
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.PackageReference">
      <summary>
            MSBuild style, project.assets.json is generated in the RestoreOutputPath folder
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.DotnetCliTool">
      <summary>
            Tool
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.Standalone">
      <summary>
            Non-MSBuild project with no project dependencies.
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.PackagesConfig">
      <summary>
            Packages.config project
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.Sha512HashFunction">
      <summary>
            A SHA-512 hash function that supports incremental hashing.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.ArgumentNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.InvalidDependencyTarget">
      <summary>
              Looks up a localized string similar to Invalid dependency target value '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.InvalidPackageType">
      <summary>
              Looks up a localized string similar to The pack options package type must be a string or array of strings in '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingLockFile">
      <summary>
              Looks up a localized string similar to Error loading lock file '{0}' : {1}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJson">
      <summary>
              Looks up a localized string similar to Error reading '{0}' : {1}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJsonWithLocation">
      <summary>
              Looks up a localized string similar to Error reading '{0}' at line {1} column {2} : {3}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_InvalidImportFramework">
      <summary>
              Looks up a localized string similar to Imports contains an invalid framework: '{0}' in '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingToolName">
      <summary>
              Looks up a localized string similar to Unable to resolve tool ''..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnDependency">
      <summary>
              Looks up a localized string similar to Package dependencies must specify a version range..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnTool">
      <summary>
              Looks up a localized string similar to Tools must specify a version range..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Imports">
      <summary>
            A fallback PCL framework to use when no compatible items
            were found for <see cref="P:NuGet.ProjectModel.TargetFrameworkInformation.FrameworkName" />.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Warn">
      <summary>
            Display warnings when the Imports framework is used.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol670378.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol670378.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Protocol670378.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol670378.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="P:NuGet.Repositories.LocalPackageInfo.Nuspec">
      <summary>
            Caches the nuspec reader.
            If the nuspec does not exist this will throw a friendly exception.
            </summary>
    </member>
    <member name="T:NuGet.Repositories.NuGetv3LocalRepository">
      <summary>
            Caches package info from the global packages folder in memory.
            Packages not yet in the cache will be retrieved from disk.
            </summary>
    </member>
    <member name="M:NuGet.Repositories.NuGetv3LocalRepository.ClearCacheForIds(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Remove cached results for the given ids. This is needed
            after installing a new package.
            </summary>
    </member>
    <member name="M:NuGet.Repositories.NuGetv3LocalRepositoryUtility.GetPackage(System.Collections.Generic.IReadOnlyList{NuGet.Repositories.NuGetv3LocalRepository},System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Take the first match on id and version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.CachingSourceProvider">
      <summary>
            A caching source repository provider intended to be used as a singleton.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.GetRepositories">
      <summary>
            Retrieve repositories that have been cached.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.CreateRepository(System.String)">
      <summary>
            Create a repository and add it to the cache.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository and add it to the cache.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.ToJson(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Serialize object to the JSON.
            </summary>
      <param name="obj">The object.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson``1(System.String)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <typeparam name="T">Type of object</typeparam>
      <param name="json">JSON representation of object</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <typeparam name="T">Type of object</typeparam>
      <param name="json">JSON representation of object</param>
      <param name="settings">The settings.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson(System.String,System.Type)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <param name="json">JSON representation of object</param>
      <param name="type">The object type.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.ToJToken(System.Object)">
      <summary>
            Serialize object to JToken.
            </summary>
      <param name="obj">The object.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJToken``1(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Deserialize object directly from JToken.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
      <param name="jtoken">The JToken to be deserialized.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJToken(Newtonsoft.Json.Linq.JToken,System.Type)">
      <summary>
            Deserialize object directly from JToken.
            </summary>
      <param name="jtoken">The JToken to be deserialized.</param>
      <param name="type">The object type.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.GetJObjectProperty``1(Newtonsoft.Json.Linq.JObject,System.String)">
      <summary>
            Extract the property directly from JObject.
            </summary>
      <typeparam name="T">Type of property to return.</typeparam>
      <param name="jobject">The JObject to be deserialized.</param>
      <param name="propertyName">The property name.</param>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetDependencies(NuGet.Protocol.HttpSource,System.Uri,NuGet.Versioning.VersionRange,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the <see cref="T:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo" /> for a registration.
            </summary>
      <returns>Returns an empty sequence if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.ProcessPackageVersion(Newtonsoft.Json.Linq.JObject,NuGet.Versioning.NuGetVersion)">
      <summary>
            Process an individual package version entry
            </summary>
      <param name="packageObj">
      </param>
      <param name="version">
      </param>
      <returns>Returns the RemoteSourceDependencyInfo object corresponding to this package version</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetRegistrationInfo(NuGet.Protocol.HttpSource,System.Uri,NuGet.Versioning.VersionRange,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve a registration blob
            </summary>
      <returns>Returns Null if the package does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetFramework(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Retrieve the target framework from a dependency group obj
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.Undefined">
      <summary>
            Undetermined type
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.HttpV2">
      <summary>
            V2 OData protocol, ex: https://www.nuget.org/api/v2/
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.HttpV3">
      <summary>
            V3 Json protocol, ex: https://api.nuget.org/v3/index.json
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemV2">
      <summary>
            Flat folder of nupkgs
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemV3">
      <summary>
            Version folder structure used for project.json
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemUnzipped">
      <summary>
            Unzipped folder of nupkgs used by project templates
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemPackagesConfig">
      <summary>
            Packages.config packages folder format
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemUnknown">
      <summary>
            Undetermined folder type. Occurs when the folder is empty
            or does not exist yet.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FeedTypePackageSource">
      <summary>
            PackageSource that can carry a feed type used to override the source repository and provide a 
            hint for the expected type.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.FeedTypePackageSource.FeedType">
      <summary>
            Feed type, ex: HttpV2, FileSystemV3
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FeedTypeResource">
      <summary>
            Resource wrapper for FeedType.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.AmbientAuthenticationState">
      <summary>
            Represents source authentication status per active operation
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DownloadTimeoutStreamContent">
      <summary>
            A wrapper around <see cref="T:System.Net.Http.StreamContent" /> that applies a <see cref="T:NuGet.Protocol.DownloadTimeoutStream" />
            to the contained stream. When the <see cref="T:System.Net.Http.HttpResponseMessage" /> is disposed, this
            content is disposed which in turn disposes the <see cref="T:NuGet.Protocol.DownloadTimeoutStream" />, which
            disposes the actual network stream.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.HttpHandlerResourceV3">
      <summary>
            Resource wrapper for an HttpClient
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpHandlerResourceV3.CredentialsSuccessfullyUsed">
      <summary>
            Gets or sets a delegate that is to be invoked when authenticated feed credentials are successfully
            used.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.Clone(System.Net.Http.HttpRequestMessage)">
      <summary>
            Clones an <see cref="T:System.Net.Http.HttpRequestMessage" /> request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.GetOrCreateConfiguration(System.Net.Http.HttpRequestMessage)">
      <summary>
            Retrieves the HTTP request configuration instance attached to the given message as custom property.
            </summary>
      <param name="request">The HTTP request message.</param>
      <returns>Configuration instance if exists, or a default instance otherwise.</returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.SetConfiguration(System.Net.Http.HttpRequestMessage,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Attaches an HTTP request configuration instance to the given message as custom property.
            If the configuration has already been set on the request message, the old configuration
            is replaced.
            </summary>
      <param name="request">The HTTP request message.</param>
      <param name="configuration">An HTTP request message configuration instance.</param>
    </member>
    <member name="T:NuGet.Protocol.HttpRequestMessageFactory">
      <summary>
            Factory class containing methods facilitating creation of <see cref="T:System.Net.Http.HttpRequestMessage" /> 
            with additional custom parameters.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.String,NuGet.Common.ILogger)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="log">Logger instance to be attached</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.Uri,NuGet.Common.ILogger)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="log">Logger instance to be attached</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.String,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="configuration">The request configuration</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.Uri,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="configuration">The request configuration</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="T:NuGet.Protocol.HttpRetryHandler">
      <summary>
            The <see cref="T:NuGet.Protocol.HttpRetryHandler" /> is for retrying and HTTP request if it times out, has any exception,
            or returns a status code of 500 or greater.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Make an HTTP request while retrying after failed attempts or timeouts.
            </summary>
      <remarks>
            This method accepts a factory to create instances of the <see cref="T:System.Net.Http.HttpRequestMessage" /> because
            requests cannot always be used. For example, suppose the request is a POST and contains content
            of a stream that can only be consumed once.
            </remarks>
    </member>
    <member name="T:NuGet.Protocol.HttpRetryHandlerRequest">
      <summary>
            A request to be handled by <see cref="T:NuGet.Protocol.HttpRetryHandler" />. This type should contain all
            of the knowledge necessary to make a request, while handling transient transport errors.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.HttpClient">
      <summary>The HTTP client to use for each request attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RequestFactory">
      <summary>
            The factory that generates each request message. This factory is invoked for each attempt.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.CompletionOption">
      <summary>The HTTP completion option to use for the next attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RequestTimeout">
      <summary>How long to wait on the request to come back with a response.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RetryDelay">
      <summary>How long to wait before trying again after a failed request.</summary>
      <summary>This API is intended only for testing purposes and should not be used in product code.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="M:NuGet.Protocol.HttpSource.GetAsync``1(NuGet.Protocol.HttpSourceCachedRequest,System.Func{NuGet.Protocol.HttpSourceResult,System.Threading.Tasks.Task{``0}},NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Caching Get request.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSource.RetryHandler">
      <summary>The retry handler to use for all HTTP requests.</summary>
      <summary>This API is intended only for testing purposes and should not be used in product code.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceCachedRequest">
      <summary>
            A cached HTTP request handled by <see cref="T:NuGet.Protocol.HttpSource" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.Uri">
      <summary>
            The URI to request with <code>GET</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.CacheKey">
      <summary>
            The cache key to use when fetching and storing the response from the HTTP cache. This
            cache key is scoped to the NuGet source. That is to say that each NuGet source has its
            own independent HTTP cache.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.CacheContext">
      <summary>
            The cache context.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.AcceptHeaderValues">
      <summary>
            The header values to apply when building the <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.IgnoreNotFounds">
      <summary>
            When processing the <see cref="T:System.Net.Http.HttpResponseMessage" />, this flag allows
            <code>404 Not Found</code> to be interpreted as a null response. This value defaults
            to <code>false</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.EnsureValidContents">
      <summary>
            A method used to validate the response stream. This method should not
            dispose the stream and should throw an exception when the content is invalid.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.RequestTimeout">
      <summary>
            The timeout to use when fetching the <see cref="T:System.Net.Http.HttpResponseMessage" />. Since
            <see cref="T:NuGet.Protocol.HttpSource" /> only uses <see cref="F:System.Net.Http.HttpCompletionOption.ResponseHeadersRead" />,
            this means that we wait this amount of time for only the HTTP headers to be returned.
            Downloading the response body is not included in this timeout.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceCredentials">
      <summary>
            A mutable CredentialCache wrapper. This allows the underlying ICredentials to
            be changed to work around HttpClientHandler not allowing Credentials to change.
            This class intentionally inherits from CredentialCache to support authentication on redirects.
            According to System.Net implementation any other ICredentials implementation is dropped for security reasons.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.HttpSourceCredentials._credentials">
      <summary>
            Credentials can be changed by other threads, for this reason volatile
            is added below so that the value is not cached anywhere.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpSourceCredentials.#ctor(System.Net.ICredentials)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.HttpSourceCredentials" /> class
            </summary>
      <param name="credentials">
            Optional initial credentials. May be null.
            </param>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCredentials.Credentials">
      <summary>
            The latest credentials to be used.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCredentials.Version">
      <summary>
            The latest version ID of the <see cref="P:NuGet.Protocol.HttpSourceCredentials.Credentials" />.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceRequest">
      <summary>
            A non-cached HTTP request handled by <see cref="T:NuGet.Protocol.HttpSource" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.RequestFactory">
      <summary>
            A factory that can be called repeatedly to build the HTTP request message.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.IgnoreNotFounds">
      <summary>
            When processing the <see cref="T:System.Net.Http.HttpResponseMessage" />, this flag allows
            <code>404 Not Found</code> to be interpreted as a null response. This value defaults
            to <code>false</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.RequestTimeout">
      <summary>
            The timeout to use when fetching the <see cref="T:System.Net.Http.HttpResponseMessage" />. Since
            <see cref="T:NuGet.Protocol.HttpSource" /> only uses <see cref="F:System.Net.Http.HttpCompletionOption.ResponseHeadersRead" />,
            this means that we wait this amount of time for only the HTTP headers to be returned.
            Downloading the response body is not included in this timeout.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceResource">
      <summary>
            Holds a shared <see cref="P:NuGet.Protocol.HttpSourceResource.HttpSource" />. 
            This is expected to be shared across the app and should not be disposed of.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceResourceProvider.Throttle">
      <summary>
            The throttle to apply to all <see cref="T:NuGet.Protocol.HttpSource" /> HTTP requests.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.IThrottle">
      <summary>
            An interface used for throttling operations. For example, suppose the application needs to
            limit the concurrency of HTTP operations. Before executing each HTTP operation, the
            <see cref="M:NuGet.Protocol.IThrottle.WaitAsync" /> would be executed. After the HTTP operation has been completed, the
            application should call <see cref="M:NuGet.Protocol.IThrottle.Release" />. The implementation of <see cref="M:NuGet.Protocol.IThrottle.WaitAsync" />
            should only allow the application to continue if there is an appropriate number of concurrent
            callers. The primary implementation of this interface simply wraps a <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.IThrottle.WaitAsync">
      <summary>
            Waits until an appropriate level of concurrency has been reached before allowing the
            caller to continue.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.IThrottle.Release">
      <summary>
            Signals that the throttled operation has been completed and other threads can being
            their own throttled operation.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.NullThrottle">
      <summary>
            An throttle implementation that allows any level of concurrency. That is, the
            <see cref="M:NuGet.Protocol.NullThrottle.WaitAsync" /> and <see cref="M:NuGet.Protocol.NullThrottle.Release" /> methods do nothing.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.ProxyAuthenticationHandler">
      <summary>
            A message handler responsible for retrying request for authenticated proxies
            with missing credentials.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSEndPointHeader">
      <summary>
            Response header that specifies the WSTrust13 Windows Transport endpoint.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSRealmHeader">
      <summary>
            Response header that specifies the realm to authenticate for. In most cases this would be the gallery we are going up against.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSTokenHeader">
      <summary>
            Request header that contains the SAML token.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StsAuthenticationHandler.PrepareSTSRequest(System.Net.Http.HttpRequestMessage)">
      <summary>
            Adds the SAML token as a header to the request if it is already cached for this source.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StsAuthenticationHandler.TryRetrieveSTSToken(System.Net.Http.HttpResponseMessage)">
      <summary>
            Attempts to retrieve a SAML token if the response indicates that server requires STS-based auth.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV2Feed.CreateDependencyInfo(NuGet.Protocol.V2FeedPackageInfo,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Convert a V2 feed package into a V3 PackageDependencyInfo
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed">
      <summary>
            A resource for detecting a V2 feed's capabilities based on the metadata document.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed.DataServiceMetadataExtractor">
      <summary>
            This implementation is copied from NuGet 2.x.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ODataServiceDocumentResourceV2Provider.MaxCacheDuration">
      <summary>
            Maximum amount of time to store index.json
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedPackageInfo">
      <summary>
            Represents a V2 package entry from the OData feed. This object primarily just holds the strings parsed from XML, all parsing 
            and converting should be done after based on the scenario.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.DownloadCountAsInt">
      <summary>
            Parse DownloadCount into an integer
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.IsListed">
      <summary>
            Checks the published date
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.DependencySets">
      <summary>
            Parses Dependencies into actual groups
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedPage">
      <summary>
            A page of items from a V2 feed as well as a link to get the next page.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedParser">
      <summary>
            A light weight XML parser for NuGet V2 Feeds
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.#ctor(NuGet.Protocol.HttpSource,System.String)">
      <summary>
            Creates a V2 parser
            </summary>
      <param name="httpSource">HttpSource and message handler containing auth/proxy support</param>
      <param name="baseAddress">base address for all services from this OData service</param>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.#ctor(NuGet.Protocol.HttpSource,System.String,System.String)">
      <summary>
            Creates a V2 parser
            </summary>
      <param name="httpSource">HttpSource and message handler containing auth/proxy support</param>
      <param name="baseAddress">base address for all services from this OData service</param>
      <param name="source">PackageSource useful for reporting meaningful errors that relate back to the configuration</param>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetPackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get an exact package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(System.String,System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves all packages with the given Id from a V2 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves all packages with the given Id from a V2 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.ParsePage(System.Xml.Linq.XDocument,System.String,NuGet.Protocol.MetadataReferenceCache)">
      <summary>
            Finds all entries on the page and parses them
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.ParsePackage(System.String,System.Xml.Linq.XElement,NuGet.Protocol.MetadataReferenceCache)">
      <summary>
            Parse an entry into a V2FeedPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetString(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
      <summary>
            Retrieve an XML <see cref="T:System.String" /> value safely
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetDate(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
      <summary>
            Retrieve an XML <see cref="T:System.DateTimeOffset" /> value safely
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedQueryBuilder">
      <summary>
            Build the path part of a V2 feed URL. These values are appended to the V2 base URL.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourcePackagesConfig">
      <summary>
            Packages.config packages folder reader
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider">
      <summary>
            Reads packages.config packages folders. The expected format is root/id.version/id.version.nupkg
            This resource cannot handle packages folders in the format root/id (exclude version)
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourceUnzipped">
      <summary>
            Unzipped package repository reader used for project templates.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetIndex(System.Lazy{System.Collections.Generic.IReadOnlyList{NuGet.Protocol.LocalPackageInfo}})">
      <summary>
            Id + Version -&gt; Package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetPathIndex(System.Lazy{System.Collections.Generic.IReadOnlyList{NuGet.Protocol.LocalPackageInfo}})">
      <summary>
            Uri -&gt; Package
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourceV3">
      <summary>
            Retrieve packages from a local folder or UNC share that uses the V3 folder structure.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="packageId">package id</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.CreateDependencyInfo(NuGet.Protocol.LocalPackageInfo,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Convert a package into a PackageDependencyInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageInfo.#ctor(NuGet.Packaging.Core.PackageIdentity,System.String,System.DateTime,System.Lazy{NuGet.Packaging.NuspecReader},System.Func{NuGet.Packaging.PackageReaderBase})">
      <summary>
            Local nuget package.
            </summary>
      <param name="identity">Package id and version.</param>
      <param name="path">Path to the nupkg.</param>
      <param name="lastWriteTimeUtc">Last nupkg write time for publish date.</param>
      <param name="nuspec">Nuspec XML.</param>
      <param name="getPackageReader">Method to retrieve the package as a reader.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageInfo.GetReader">
      <summary>
            Package reader.
            </summary>
      <remarks>This creates a new instance each time. Callers need to dispose of it.</remarks>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Identity">
      <summary>
            Package id and version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Path">
      <summary>
            Nupkg or folder path.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.LastWriteTimeUtc">
      <summary>
            Last file write time. This is used for the publish date.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Nuspec">
      <summary>
            Nuspec reader.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchResource.ContainsAnyTerm(System.String[],NuGet.Protocol.LocalPackageInfo)">
      <summary>
            Search Id, Tags, and Description to match the legacy local search behavior.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchResource.CollapseToHighestVersion(System.Collections.Generic.IEnumerable{NuGet.Protocol.LocalPackageInfo})">
      <summary>
            Returns a distinct set of elements using the comparer specified. This implementation will pick the last occurrence
            of each element instead of picking the first. This method assumes that similar items occur in order.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalV2FindPackageByIdResourceProvider">
      <summary>
            A v2-style package repository that has nupkgs at the root.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalV3FindPackageByIdResourceProvider">
      <summary>
            A v3-style package repository that has expanded packages.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchMetadata.Convert(System.String)">
      <summary>
            Convert a string to a URI safely. This will return null if there are errors.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.PackageSearchMetadataRegistration">
      <summary>
            Subclass of <see cref="T:NuGet.Protocol.PackageSearchMetadata" /> containing the information in the registration blobs that are not present in the V2 feed or search.
            Returned by <see cref="T:NuGet.Protocol.PackageMetadataResourceV3" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.PackageSearchMetadataRegistration.CatalogUri">
      <summary>
            The <see cref="T:System.Uri" /> of this package in the catalog.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexEntry">
      <summary>
            index.json entry for v3
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.Uri">
      <summary>
            Service Uri
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.Type">
      <summary>
            Service Type
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.ClientVersion">
      <summary>
            Client version
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DependencyInfoResourceV3Provider">
      <summary>
            Retrieves all dependency info for the package resolver.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexResourceV3Provider">
      <summary>
            Retrieves and caches service index.json files
            ServiceIndexResourceV3 stores the json, all work is done in the provider
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3Provider.MaxCacheDuration">
      <summary>
            Maximum amount of time to store index.json
            </summary>
    </member>
    <member name="T:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource">
      <summary>
            A <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> for a Http-based file system where files are laid out in the
            format
            /root/
            PackageA/
            Version0/
            PackageA.nuspec
            PackageA.Version0.nupkg
            and are accessible via HTTP Gets.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.PackageUtilities.OpenNuspecFromNupkg(System.String,System.IO.Stream,NuGet.Common.ILogger)">
      <summary>
            Create a <see cref="T:NuGet.Packaging.NuspecReader" /> from a nupkg stream.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider">
      <summary>
            A <see cref="T:NuGet.Protocol.Core.Types.ResourceProvider" /> for <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> over v2 NuGet feeds.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DependencyInfoResourceV3">
      <summary>
            Retrieves all packages and dependencies from a V3 source.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.#ctor(NuGet.Protocol.HttpSource,NuGet.Protocol.RegistrationResourceV3,NuGet.Protocol.Core.Types.SourceRepository)">
      <summary>
            Dependency info resource
            </summary>
      <param name="client">Http client</param>
      <param name="regResource">Registration blob resource</param>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>
            Returns dependency info for the given package if it exists. If the package is not found null is
            returned.
            </returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.GetPackagesFromRegistration(NuGet.Protocol.RegistrationInfo,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info from a registration blob
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DownloadResourceV3">
      <summary>
            Provides the download metatdata for a given package from a V3 server endpoint.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.#ctor(NuGet.Protocol.HttpSource,NuGet.Protocol.RegistrationResourceV3)">
      <summary>
            Download packages using the download url found in the registration resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.#ctor(NuGet.Protocol.HttpSource,System.String)">
      <summary>
            Download packages using the package base address container resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.GetDownloadUrl(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get the download url of the package.
            1. If the identity is a SourcePackageDependencyInfo the SourcePackageDependencyInfo.DownloadUri is used.
            2. A url will be constructed for the flat container location if the source has that resource.
            3. The download url will be found in the registration blob as a fallback.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.MetadataResourceV3">
      <summary>
            Returns the full package metadata
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataResourceV3.GetLatestVersions(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Find the latest version of the package
            </summary>
      <param name="includePrerelease">include versions with prerelease labels</param>
      <param name="includeUnlisted">not implemented yet</param>
    </member>
    <member name="T:NuGet.Protocol.RegistrationResourceV3">
      <summary>
            Registration blob reader
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(System.String)">
      <summary>
            Constructs the URI of a registration index blob
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Constructs the URI of a registration blob with a specific version
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Constructs the URI of a registration blob with a specific version
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns the registration blob for the id and version
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(System.String,System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns inlined catalog entry items for each registration blob
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(System.String,NuGet.Versioning.VersionRange,System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns inlined catalog entry items for each registration blob
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageEntries(System.String,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns all index entries of type Package within the given range and filters
            </summary>
    </member>
    <member name="P:NuGet.Protocol.RegistrationResourceV3.BaseUri">
      <summary>
            Gets the <see cref="T:System.Uri" /> for the source backing this resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ReportAbuseResourceV3.GetReportAbuseUrl(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets a URL for reporting package abuse. The URL will not be verified to exist.
            </summary>
      <param name="id">The package id (natural casing)</param>
      <param name="version">The package version</param>
      <returns>The first URL from the resource, with the URI template applied.</returns>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexResourceV3">
      <summary>
            Stores/caches a service index json file.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(System.String[])">
      <summary>
            Get the list of service entries that best match the current clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(NuGet.Versioning.NuGetVersion,System.String[])">
      <summary>
            Get the list of service entries that best match the clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUri(System.String[])">
      <summary>
            Get the best match service URI.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(System.String[])">
      <summary>
            Get the list of service URIs that best match the current clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(NuGet.Versioning.NuGetVersion,System.String[])">
      <summary>
            Get the list of service URIs that best match the clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetValues(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Read string values from an array or string.
            Returns an empty enumerable if the value is null.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3.RequestTime">
      <summary>
            Time the index was requested
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3.Entries">
      <summary>
            All service index entries.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionExecutor_RollingBack">
      <summary>
              Looks up a localized string similar to Install failed. Rolling back....
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionResolver_UnsupportedAction">
      <summary>
              Looks up a localized string similar to Unrecognized Package Action '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionResolver_UnsupportedDependencyBehavior">
      <summary>
              Looks up a localized string similar to Unsupported Dependency Behavior '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_ExistingPackageInvalid">
      <summary>
              Looks up a localized string similar to Package '{0}' already exists at feed '{1}' and is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_PackageAlreadyExists">
      <summary>
              Looks up a localized string similar to Package '{0}' already exists at feed '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_SuccessfullyAdded">
      <summary>
              Looks up a localized string similar to Successfully added package '{0}' to feed '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Argument can not be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ArgumentCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DefaultSymbolServer">
      <summary>
              Looks up a localized string similar to the symbol server.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandCanceled">
      <summary>
              Looks up a localized string similar to Delete canceled.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandConfirm">
      <summary>
              Looks up a localized string similar to {0} {1} will be deleted from the {2}. Would you like to continue?.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandDeletedPackage">
      <summary>
              Looks up a localized string similar to {0} {1} was deleted successfully..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandDeletingPackage">
      <summary>
              Looks up a localized string similar to Deleting {0} {1} from the {2}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeletePackage_NotFound">
      <summary>
              Looks up a localized string similar to Not Found..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DownloadActionHandler_InvalidDownloadUrl">
      <summary>
              Looks up a localized string similar to The download URL for {0} '{1}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DownloadActionHandler_NoDownloadUrl">
      <summary>
              Looks up a localized string similar to No download URL could be found for {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Error_DownloadTimeout">
      <summary>
              Looks up a localized string similar to The download of '{0}' timed out because no data was received for {1}ms..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForForbidden">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '403 Forbidden' when accessing the source '{0}'. This suggests that the server has authenticated your identity but has not permitted you to access the requested resource. Provide credentials that have permissions to view this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForProxy">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '407 Proxy Authentication Required' when accessing the proxy '{0}'. This suggests that the server needs credentials to authenticate your identity to use a proxy. Provide credentials to access this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForUnauthorized">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '401 Unauthorized' when accessing the source '{0}'. This suggests that the server needs credentials to authenticate your identity. Provide credentials to access this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_RequestLog">
      <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_ResponseLog">
      <summary>
              Looks up a localized string similar to {0} {1} {2}ms.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_Timeout">
      <summary>
              Looks up a localized string similar to The HTTP request to '{0} {1}' has timed out after {2}ms..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.InvalidVersionFolder">
      <summary>
              Looks up a localized string similar to The folder '{0}' contains an invalid version..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.LiveFeed">
      <summary>
              Looks up a localized string similar to the NuGet gallery.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_CanceledNupkgDownload">
      <summary>
              Looks up a localized string similar to Downloading a package from '{0}' was canceled..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_ErrorDownloading">
      <summary>
              Looks up a localized string similar to Error downloading '{0}' from '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToDownloadPackage">
      <summary>
              Looks up a localized string similar to Failed to download package '{0}' from '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToFetchV2Feed">
      <summary>
              Looks up a localized string similar to The V2 feed at '{0}' returned an unexpected status code '{1} {2}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToGetNupkgStream">
      <summary>
              Looks up a localized string similar to Unable to load package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToGetNuspecStream">
      <summary>
              Looks up a localized string similar to Unable to load nuspec from package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToReadServiceIndex">
      <summary>
              Looks up a localized string similar to Unable to load the service index for source {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToRetrievePackage">
      <summary>
              Looks up a localized string similar to Failed to retrieve information about '{0}' from remote source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToVerifyRootDirectory">
      <summary>
              Looks up a localized string similar to Failed to verify the root directory of local source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToVerifyValidFile">
      <summary>
              Looks up a localized string similar to Failed to validate the file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FileIsCorrupt">
      <summary>
              Looks up a localized string similar to The file '{0}' is corrupt..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_InvalidCacheEntry">
      <summary>
              Looks up a localized string similar to An invalid cache entry was found for URL '{0}' and will be replaced..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_InvalidNupkgFromUrl">
      <summary>
              Looks up a localized string similar to The nupkg at '{0}' is not valid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingFindPackagesById">
      <summary>
              Looks up a localized string similar to Retrying '{0}' for source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingHttp">
      <summary>
              Looks up a localized string similar to An error was encountered when fetching '{0} {1}'. The request will now be retried..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingServiceIndex">
      <summary>
              Looks up a localized string similar to Retrying service index request for source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NoApiKeyFound">
      <summary>
              Looks up a localized string similar to No API Key was provided and no API Key could be found for {0}. To save an API Key for a source use the 'setApiKey' command..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NuGetRepository_CannotCreateAggregateRepo">
      <summary>
              Looks up a localized string similar to Cannot create a NuGet Repository from the Aggregate Source.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NuGetServiceProvider_ServiceNotSupported">
      <summary>
              Looks up a localized string similar to The {0} service is not supported by this object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NupkgPath_Invalid">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid nupkg file..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NupkgPath_InvalidEx">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid nupkg file. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.OneOrMoreUrisMustBeSpecified">
      <summary>
              Looks up a localized string similar to One or more URIs must be specified..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PackageActionDescriptionWrapper_UnrecognizedAction">
      <summary>
              Looks up a localized string similar to Unrecognized Package Action '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PackageServerEndpoint_NotSupported">
      <summary>
              Looks up a localized string similar to ERROR: This version of nuget.exe does not support updating packages to package source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Path_Invalid">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid path..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Path_Invalid_NotFileNotUnc">
      <summary>
              Looks up a localized string similar to '{0}' should be a local path or a UNC share path..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ProjectInstallationTarget_ProjectIsNotTargetted">
      <summary>
              Looks up a localized string similar to The project '{0}' is not one of the projects targetted by this object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_BadSource">
      <summary>
              Looks up a localized string similar to Failed to retrieve metadata from source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_duplicateUri">
      <summary>
              Looks up a localized string similar to '{0}' is a duplicate url which has already been downloaded and will lead to a cyclic dependency. Please correct from server..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_FlatContainerIndexVersionsNotArray">
      <summary>
              Looks up a localized string similar to The 'versions' property at '{0}' must be an array..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_IndexMissingResourcesNode">
      <summary>
              Looks up a localized string similar to Service index document is missing the 'resources' property..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidJsonObject">
      <summary>
              Looks up a localized string similar to The content at '{0}' is not a valid JSON object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidServiceIndex">
      <summary>
              Looks up a localized string similar to The source does not have the 'version' property at '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidXml">
      <summary>
              Looks up a localized string similar to The content at '{0}' is not valid XML..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MalformedMetadataError">
      <summary>
              Looks up a localized string similar to Metadata could not be loaded from the source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingRegistrationBase">
      <summary>
              Looks up a localized string similar to The source does not have a Registration Base Url defined!.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingSearchService">
      <summary>
              Looks up a localized string similar to The source does not have a Search service!.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingVersion">
      <summary>
              Looks up a localized string similar to The source does not have the 'version' property..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_PackageMetadataError">
      <summary>
              Looks up a localized string similar to An error occurred while retrieving package metadata for '{0}' from source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_Search_LocalSourceNotFound">
      <summary>
              Looks up a localized string similar to The path '{0}' for the selected source could not be resolved..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_UnsupportedVersion">
      <summary>
              Looks up a localized string similar to The source version is not supported: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PushCommandPackagePushed">
      <summary>
              Looks up a localized string similar to Your package was pushed..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PushCommandPushingPackage">
      <summary>
              Looks up a localized string similar to Pushing {0} to {1}....
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.RequiredFeatureUnsupportedException_DefaultMessageWithFeature">
      <summary>
              Looks up a localized string similar to The '{0}' installation feature was required by a package but is not supported on the current host..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.RequiredFeatureUnsupportedException_DefaultMessageWithoutFeature">
      <summary>
              Looks up a localized string similar to The installation host does not support a feature required by this package..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.UnableToFindFile">
      <summary>
              Looks up a localized string similar to File does not exist ({0})..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.UnableToParseFolderV3Version">
      <summary>
              Looks up a localized string similar to Unable to parse a valid version from a v3 folder: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.v2sourceDescription">
      <summary>
              Looks up a localized string similar to API v2 (legacy).
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.v3sourceDescription">
      <summary>
              Looks up a localized string similar to API v3.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Warning_SymbolServerNotConfigured">
      <summary>
              Looks up a localized string similar to Found symbols package '{0}', but no API key was specified for the symbol server. To save an API Key, run 'NuGet.exe setApiKey [your API key from http://www.NuGet.org]'..
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FeedTypeUtility.GetFeedType(NuGet.Configuration.PackageSource)">
      <summary>
            Determine the type of a nuget source. This works for both offline and online sources.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.GetNuspecReaderFromNupkgAsync(NuGet.Packaging.Core.PackageIdentity,System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Gets a <see cref="T:NuGet.Packaging.NuspecReader" /> from a .nupkg. If the URL cannot be fetched or there is a problem
            processing the .nuspec, an exception is throw. This method uses HTTP caching to avoid downloading the
            package over and over (unless <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload" /> is specified).
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>The .nuspec reader.</returns>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.CopyNupkgToStreamAsync(NuGet.Packaging.Core.PackageIdentity,System.String,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Copies a .nupkg stream to the <paramref name="destination" /> stream. If the .nupkg cannot be found or if
            there is a network problem, no stream copy occurs.
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg.</param>
      <param name="destination">The destination stream. The .nupkg will be copied to this stream.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>Returns true if the stream was copied, false otherwise.</returns>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.ProcessNupkgStreamAsync(NuGet.Packaging.Core.PackageIdentity,System.String,System.Func{System.IO.Stream,System.Threading.Tasks.Task},NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Manages the different ways of getting a .nupkg stream when using the global HTTP cache. When a stream is
            found, the <paramref name="processStreamAsync" /> method is invoked on said stream. This deals with the
            complexity of <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload" />.
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg to fetch.</param>
      <param name="processStreamAsync">The method to process the stream.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>
            Returns true if the stream was processed, false if the stream could not fetched (either from the HTTP cache
            or from the network).
            </returns>
    </member>
    <member name="M:NuGet.Protocol.GetDownloadResultUtility.CleanUpDirectDownloads(NuGet.Protocol.Core.Types.PackageDownloadContext)">
      <summary>
            Allow explicit clean-up of direct download files. This is important because although direct downloads are
            opened with the <see cref="F:System.IO.FileOptions.DeleteOnClose" /> option, some systems (e.g. Linux) do not perform
            the delete if the process dies. Additionally, if the system dies before the process dies (e.g. loss of
            power), the direct download files will be left over.
            </summary>
      <param name="downloadContext">The download context.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackage(System.Uri,NuGet.Common.ILogger)">
      <summary>
            Retrieve a nupkg using the path.
            </summary>
      <param name="path">Nupkg path in uri form.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV2(System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages from a folder and one level deep.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV2(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="id">Package id.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV2(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="id">Package id.</param>
      <param name="version">Package version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV2(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="identity">Package id and version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="identity">Package id and version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderSearchPattern(System.String)">
      <summary>
            Returns either id.* or * depending on the OS.
            </summary>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Return the package nupkg from a packages.config folder sub directory.
            </summary>
      <param name="dir">Package directory in the format id.version</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the file name matches the identity. This is could be incorrect if
            the package name ends with numbers. The result should be checked against the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo,System.String)">
      <summary>
            True if the file name matches the id and is followed by a version. This is could be incorrect if
            the package name ends with numbers. The result should be checked against the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetIdentityFromNupkgPath(System.IO.FileInfo,System.String)">
      <summary>
            An imperfect attempt at finding the identity of a package from the file name.
            This can fail if the package name ends with something such as .1
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetVersionFromFileName(System.String,System.String,System.String)">
      <summary>
            An imperfect attempt at finding the version of a package from the file name.
            This can fail if the package name ends with something such as .1
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetVersionFromIdVersionString(System.String,System.String)">
      <summary>
            Parse a possible version from a string in the format Id.Version
            Returns null if the version is invalid or the id did not match.
            </summary>
      <param name="idVersionString">Id.Version</param>
      <param name="id">Expected id</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV3(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve a single package from a v3 version folder.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV3(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package from a v3 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(System.String,NuGet.Common.ILogger)">
      <summary>
            Discover all nupkgs from a v2 local folder.
            </summary>
      <param name="root">Folder root.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetAndVerifyRootDirectory(System.String)">
      <summary>
            Verify that a path could be a valid directory. Throw a FatalProtocolException otherwise.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetAndVerifyFileInfo(System.Uri)">
      <summary>
            Verify that a path could be a valid file. Throw a FatalProtocolException otherwise.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolderChunked(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Retrieve files in chunks, this helps maintain the legacy behavior of searching for
            certain non-normalized file names.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Discover nupkgs from a v2 local folder.
            </summary>
      <param name="root">Folder root.</param>
      <param name="id">Package id file name prefix.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV3(System.String,NuGet.Common.ILogger)">
      <summary>
            Discover all nupkgs from a v3 folder.
            </summary>
      <param name="root">Folder root.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV3(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Discover nupkgs from a v3 local folder.
            </summary>
      <param name="root">Folder root.</param>
      <param name="id">Package id or package id prefix.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetDistinctPackages(System.Collections.Generic.IEnumerable{NuGet.Protocol.LocalPackageInfo})">
      <summary>
            Remove duplicate packages which can occur in directories.
            In V2 packages may exist under multiple sub folders. 
            Non-normalized versions also lead to duplicates: ex: 1.0, 1.0.0.0
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetDirectoriesSafe(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Retrieve directories and log exceptions that occur.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetFilesSafe(System.IO.DirectoryInfo,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve files and log exceptions that occur.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesFromNupkgs(System.Collections.Generic.IEnumerable{System.IO.FileInfo})">
      <summary>
            Path -&gt; LocalPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageFromNupkg(System.IO.FileInfo)">
      <summary>
            Path -&gt; LocalPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromDirectory(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Find all nupkgs in the top level of a directory.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.MetadataReferenceCache">
      <summary>
            Cache strings, dates, and versions to reduce memory.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.MetadataReferenceCache.CachableTypesMap">
      <summary>
            Mapping of input parameter type to caching method.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetString(System.String)">
      <summary>
            Checks if <paramref name="s" /> already exists in the cache.
            If so, returns the cached instance.
            If not, caches <paramref name="s" /> and returns it.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetVersion(System.String)">
      <summary>
            Parses <paramref name="s" /> into a <see cref="T:NuGet.Versioning.NuGetVersion" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetObject``1(``0)">
      <summary>
            Iterates through the properties of <paramref name="input" /> that are either <see cref="T:System.String" />s, <see cref="T:System.DateTimeOffset" />s, or <see cref="T:NuGet.Versioning.NuGetVersion" />s and checks them against the cache.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.MetadataReferenceCache.CachableTypes">
      <summary>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all types that can be cached.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StreamExtensions.AsSeekableStreamAsync(System.IO.Stream)">
      <summary>
            Read a stream into a memory stream if CanSeek is false.
            This method is used to ensure that network streams
            can be read by non-async reads without hanging.
            
            Closes the original stream by default.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StreamExtensions.AsSeekableStreamAsync(System.IO.Stream,System.Boolean)">
      <summary>
            Read a stream into a memory stream if CanSeek is false.
            This method is used to ensure that network streams
            can be read by non-async reads without hanging.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.TimeoutUtility.StartWithTimeout``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.TimeSpan,System.String,System.Threading.CancellationToken)">
      <summary>
            Starts a task with a timeout. If the timeout occurs, a <see cref="T:System.TimeoutException" />
            with no message will be thrown.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.TimeoutUtility.StartWithTimeout(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.TimeSpan,System.String,System.Threading.CancellationToken)">
      <summary>
            Starts a task with a timeout. If the timeout occurs, a <see cref="T:System.TimeoutException" />
            with no message will be thrown.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.VisualStudio.FactoryExtensionsVS.GetVisualStudio(NuGet.Protocol.Core.Types.Repository.ProviderFactory)">
      <summary>
            Core V2 + Core V3 + VS
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DownloadResourceResult">
      <summary>
            The result of <see cref="T:NuGet.Protocol.Core.Types.DownloadResource" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageStream">
      <summary>
            Gets the package <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageStream" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageSource">
      <summary>
            Gets the source containing this package, if not from cache
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageReader">
      <summary>
            Gets the <see cref="T:NuGet.Packaging.PackageReaderBase" /> for the package.
            </summary>
      <remarks>This property can be null.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.NuGetProtocolException">
      <summary>
            Base protocol exception type containing a message and optional inner exception.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.#ctor(System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageDependencyGroup},System.Collections.Generic.IEnumerable{NuGet.Packaging.FrameworkSpecificGroup})">
      <summary>
            DependencyInfo
            </summary>
      <param name="dependencyGroups">package dependency groups</param>
      <param name="frameworkReferenceGroups">Sequence of <see cref="T:NuGet.Packaging.FrameworkSpecificGroup" />s.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.DependencyGroups">
      <summary>
            Gets the package dependecy groups.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.FrameworkReferenceGroups">
      <summary>
            Gets the framework reference groups.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpSourceCacheContext.RootTempFolder">
      <summary>
            A suggested root folder to drop temporary files under, it will get cleared by the
            disposal of the <see cref="T:NuGet.Protocol.Core.Types.SourceCacheContext" /> that was used to create this instance.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.INuGetResource">
      <summary>
            Represents a resource provided by a server endpoint (V2 or V3).
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.INuGetResourceProvider">
      <summary>
            INuGetResourceProviders are imported by SourceRepository. They exist as singletons which span all sources,
            and are responsible
            for determining if they should be used for the given source when TryCreate is called.
            The provider determines the caching. Resources may be cached per source, but they are normally created new
            each time
            to allow for caching within the context they were created in.
            Providers may retrieve other resources from the source repository and pass them to the resources they
            create in order
            to build on them.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.INuGetResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Attempts to create a resource for this source.
            </summary>
      <remarks>
            The provider may return true but null for the resource if the
            provider determines that it should not exist.
            </remarks>
      <param name="source">Source repository</param>
      <returns>True if this provider handles the input source.</returns>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.ResourceType">
      <summary>
            Resource type provided
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.Name">
      <summary>
            Name of the provider. This is used for ordering.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.Before">
      <summary>
            Names of providers this should be ordered BEFORE
            Gives this instance a higher priority.
            </summary>
      <remarks>If provider: default is named here, this provider will be called BEFORE default</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.After">
      <summary>
            Names of providers this should be ordered AFTER.
            Gives this instance a lower priority.
            </summary>
      <remarks>If provider: default is named here, this provider will be called AFTER default</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.ISourceRepositoryProvider">
      <summary>
            SourceRepositoryProvider composes resource providers into source repositories.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.GetRepositories">
      <summary>
            Retrieve repositories
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.PackageSourceProvider">
      <summary>
            Gets the package source provider
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.IPackageSearchMetadata">
      <summary>
            Package metadata only containing select fields relevant to search results processing and presenting.
            Immutable.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder">
      <summary>
            Helper class allowing creation/alteration of immutable package metadata objects.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions">
      <summary>
            Shortcut methods to create altered metadata objects with new versions.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.VersionInfo.PackageSearchMetadata">
      <summary>
            In V2, when finding the list of versions that a package ID has, we also get all of the metadata
            associated with each version. It would be wasteful to throw this away, so we store what we have
            here. For V3, the metadata property is null. Callers that receive this type need to be able to
            fetch this package metadata some other way if this property is null.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions">
      <summary>
            Positions to base providers on
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.First">
      <summary>
            The first provider called
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.Last">
      <summary>
            The last provider called
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.NuGetTestMode.InvokeTestFunctionAgainstTestMode``1(System.Func{``0},System.Boolean)">
      <summary>
            Intended for internal use only: utility method for testing purposes.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageProgressEventArgs.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Configuration.PackageSource,System.Double)">
      <summary>
            The status of a package action.
            </summary>
      <param name="identity">package identity</param>
      <param name="source">repository source or null</param>
      <param name="complete">0.0 - 1.0</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.PackageProgressEventArgs.Complete">
      <summary>
            Completion - 0.0 - 1.0
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.PackageProgressEventArgs.IsComplete">
      <summary>
            True at 100% completion
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.ProviderComparer">
      <summary>
            An imperfect sort for provider before/after
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo">
      <summary>
            A collection of package dependency groups with the content (nupkg url).
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.#ctor(NuGet.Packaging.Core.PackageIdentity,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageDependencyGroup},System.String)">
      <summary>
            DependencyInfo
            </summary>
      <param name="identity">package identity</param>
      <param name="dependencyGroups">package dependency groups</param>
      <param name="contentUri">The content uri for the dependency.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Identity">
      <summary>
            Package identity
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Listed">
      <summary>
            IsListed
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.DependencyGroups">
      <summary>
            Package dependency groups
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.ContentUri">
      <summary>
            The content url of this resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider})">
      <summary>
            Create the default source repository provider
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider},System.String)">
      <summary>
            Find sources from nuget.config based on the root path
            </summary>
      <param name="rootPath">lowest folder path</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},System.String)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},System.String,NuGet.Protocol.FeedType)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Configuration.PackageSource)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ResourceProvider.#ctor(System.Type,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
      </summary>
      <param name="resourceType">Type this resource provider creates</param>
      <param name="name">name used for ordering</param>
      <param name="before">providers that this provider should have precendence over</param>
      <param name="after">providers that this provider should be called after</param>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DependencyInfoResource">
      <summary>
            Provides methods for resolving a package and its dependencies. This might change based on the new
            dependency resolver.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>
            Returns dependency info for the given package if it exists. If the package is not found null is
            returned.
            </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DownloadResource">
      <summary>
            Finds the download url of a nupkg
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResource.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Downloads a package .nupkg with the provided identity. If the package is not available
            on the source but the source itself is not down or unavailable, the
            <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.Status" /> will be <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.NotFound" />.
            If the operation was cancelled, the <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.Status" /> will be
            <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.Cancelled" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Gets the <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo" /> for a specific package.
            </summary>
      <param name="id">The packag id.</param>
      <param name="version">The package version.</param>
      <param name="cacheContext">The source cache context.</param>
      <param name="logger">The logger.</param>
      <param name="token">The <see cref="T:System.Threading.CancellationToken" />.</param>
      <returns>
            A <see cref="T:System.Threading.Tasks.Task" /> that on completion returns a <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo" /> of the
            package, if found,
            <c>null</c> otherwise.
            </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetOriginalIdentityAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Gets the original ID and version for a package. This is useful when finding the
            canonical casing for a package ID. Note that the casing of a package ID can vary from
            version to version.
            </summary>
      <param name="id">The package ID. This value is case insensitive.</param>
      <param name="version">The version.</param>
      <param name="cacheContext">The source cache context.</param>
      <param name="logger">The logger.</param>
      <param name="token">The cancellation token.</param>
      <returns>The package identity, with the ID having the case provided by the package author.</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfo(NuGet.Packaging.NuspecReader)">
      <summary>
            Read dependency info from a nuspec.
            </summary>
      <remarks>This also verifies minClientVersion.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.HttpHandlerResource">
      <summary>
            An HttpClient configured for the package source
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpHandlerResource.ClientHandler">
      <summary>
            HttpClientHandler used for credential support.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpHandlerResource.MessageHandler">
      <summary>
            Message handler containing the ClientHandler.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource">
      <summary>
            A resource for detecting the capabilities of a V2 feed.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.MetadataResource">
      <summary>
            Basic metadata
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.GetVersions(System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.GetVersions(System.String,System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            True if the package exists in the source
            Includes unlisted.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            True if the package exists in the source
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(System.String,System.Boolean,System.Boolean,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Return package metadata for the input PackageIdentity
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageSearchResource.SearchAsync(System.String,NuGet.Protocol.Core.Types.SearchFilter,System.Int32,System.Int32,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves search results
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageUpdateResource">
      <summary>
            Contains logics to push or delete packages in Http server or file system
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.PackageUpdateResource.TempApiKeyServiceEndpoint">
      <summary>
            Create temporary verification api key endpoint: "create-verification-key/[package id]/[package version]"
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageUpdateResource.GetSymbolsPath(System.String)">
      <summary>
            Get the symbols package from the original package. Removes the .nupkg and adds .symbols.nupkg
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SearchFilter">
      <summary>
            A search filter context that represents the UI settings
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SearchFilter.#ctor(System.Boolean)">
      <summary>
            Initializes an instance of a <see cref="T:NuGet.Protocol.Core.Types.SearchFilter" /> and validates required parameters.
            </summary>
      <param name="includePrerelease">Whether or not to allow prerelease results.</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SearchFilter.#ctor(System.Boolean,System.Nullable{NuGet.Protocol.Core.Types.SearchFilterType})">
      <summary>
            Initializes an instance of a <see cref="T:NuGet.Protocol.Core.Types.SearchFilter" /> and validates required parameters.
            </summary>
      <param name="includePrerelease">Whether or not to allow prerelease results.</param>
      <param name="filter">The filter to apply to the results.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.SupportedFrameworks">
      <summary>
            Filter to only the list of packages compatible with these frameworks.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.IncludePrerelease">
      <summary>
            Include prerelease packages in search
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.IncludeDelisted">
      <summary>
            Include unlisted packages in search
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.PackageTypes">
      <summary>
            Restrict the search to certain package types.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.Filter">
      <summary>
            The optional filter type. Absense of this value indicates that all versions should be returned.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.OrderBy">
      <summary>
            The optional order by. Absense of this value indicates that search results should be ordered by relevance.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SearchFilterType">
      <summary>
            The type of filter to apply to the search.
            </summary>
      <remarks>
            Here are some examples to clarify what these filters mean. Suppose the very latest version is prerelease.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              ------------|------------|-----------------|------------------------
              8.0.1-beta1 | true       | false           | false
              8.0.3       | false      | false           | false
              9.0.1       | false      | true            | false
              9.0.2-beta1 | true       | false           | true
            
            Suppose the very latest version is not prerelease. Notice the latest version is also the absolute latest
            version. In other words, a prerelease package cannot be a latest version but a non-prerelease package can be
            both the latest version and the absolute latest version.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              ------------|------------|-----------------|------------------------
              8.0.1-beta1 | true       | false           | false
              8.0.3       | false      | false           | false
              9.0.1       | false      | true            | true
            
            Suppose there are only prerelease versions. Notice there are no package that has IsLatestVersion as true.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              8
              ------------|------------|-----------------|------------------------.0.1-beta1 | true       | false           | false
              9.0.2-beta1 | true       | false           | true
            
            </remarks>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion">
      <summary>
            Only select the latest stable version of a package per package ID. Given the server supports
            <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion" />, a package that is <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion" /> should never be
            prerelease. Also, it does not make sense to look for a <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion" /> package when also
            including prerelease.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion">
      <summary>
            Only select the absolute latest version of a package per package ID. It does not make sense to look for a
            <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion" /> when excluding prerelease.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchOrderBy.Id">
      <summary>
            Order the resulting packages by package ID.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceCacheContext">
      <summary>
            Cache control settings for the V3 disk cache.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SourceCacheContext._generatedTempFolder">
      <summary>
            Path of temp folder if requested by GeneratedTempFolder
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SourceCacheContext.DefaultMaxAge">
      <summary>
            Default amount of time to cache version lists.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.NoCache">
      <summary>
            If set, the global disk cache will not be written to or read from. Instead, a temporary directory will be
            used.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload">
      <summary>
            If set, the global disk cache will not be written to.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.MaxAge">
      <summary>
            Package version lists or packages from the server older than this date will be fetched from the server.
            </summary>
      <remarks>This will be ignored if <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.NoCache" /> is true.</remarks>
      <remarks>If the value is null the default expiration will be used.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.MaxAgeTimeSpan">
      <summary>
            Package version lists from the server older than this time span
            will be fetched from the server.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Listed">
      <summary>
            True if the package is listed and shown in search.
            </summary>
      <remarks>This property only applies to online sources.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Source">
      <summary>
            Source repository the dependency information was retrieved from.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.DownloadUri">
      <summary>
            The HTTP, UNC, or local file URI to the package nupkg.
            </summary>
      <remarks>Optional</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.PackageHash">
      <summary>
            Package hash
            </summary>
      <remarks>Optional</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceRepository">
      <summary>
            Represents a Server endpoint. Exposes methods to get a specific resource such as Search, Metrics service
            and so on for the given server endpoint.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider})">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Protocol.FeedType)">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
      <param name="feedTypeOverride">Restrict the source to this feed type.</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor">
      <summary>
            Internal default constructor
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetFeedType(System.Threading.CancellationToken)">
      <summary>
            Find the FeedType of the source. If overridden FeedTypeOverride is returned.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResource``1">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResource``1(System.Threading.CancellationToken)">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync``1">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync``1(System.Threading.CancellationToken)">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.Init(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Initialize provider cache
            </summary>
      <param name="providers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetFeedType(NuGet.Configuration.PackageSource)">
      <summary>
            Get the feed type from the package source.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceRepository.FeedTypeOverride">
      <summary>
            Pre-determined feed type.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceRepository.PackageSource">
      <summary>
            Package source
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceRepositoryProvider">
      <summary>
            SourceRepositoryProvider is the high level source for repository objects representing package sources.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.#ctor(NuGet.Configuration.IPackageSourceProvider,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Non-MEF constructor
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.GetRepositories">
      <summary>
            Retrieve repositories
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.UserAgent.SetUserAgent(System.Net.Http.HttpClient)">
      <summary>
            Set user agent string on HttpClient to the static string.
            </summary>
      <param name="client">Http client</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning853995.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning853995.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Versioning853995.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning853995.HashCodeCombiner.GetHashCode(System.Object[])">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="T:NuGet.Versioning.FloatRange">
      <summary>
            The floating subset of a version range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior)">
      <summary>
            Create a floating range.
            </summary>
      <param name="floatBehavior">Section to float.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior,NuGet.Versioning.NuGetVersion)">
      <summary>
            Create a floating range.
            </summary>
      <param name="floatBehavior">Section to float.</param>
      <param name="minVersion">Min version of the range.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior,NuGet.Versioning.NuGetVersion,System.String)">
      <summary>
            FloatRange
            </summary>
      <param name="floatBehavior">Section to float.</param>
      <param name="minVersion">Min version of the range.</param>
      <param name="releasePrefix">The original release label. Invalid labels are allowed here.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Satisfies(NuGet.Versioning.NuGetVersion)">
      <summary>
            True if the given version falls into the floating range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Parse(System.String)">
      <summary>
            Parse a floating version into a FloatRange
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.TryParse(System.String,NuGet.Versioning.FloatRange@)">
      <summary>
            Parse a floating version into a FloatRange
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.ToString">
      <summary>
            Create a floating version string in the format: 1.0.0-alpha-*
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Equals(NuGet.Versioning.FloatRange)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.GetHashCode">
      <summary>
            Hash code
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.HasMinVersion">
      <summary>
            True if a min range exists.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.MinVersion">
      <summary>
            The minimum version of the float range. This is null for cases such as *
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.FloatBehavior">
      <summary>
            Defined float behavior
            </summary>
    </member>
    <member name="T:NuGet.Versioning.INuGetVersionable">
      <summary>
            An item that exposes a NuGetVersion
            </summary>
    </member>
    <member name="P:NuGet.Versioning.INuGetVersionable.Version">
      <summary>
            NuGet semantic version
            </summary>
    </member>
    <member name="T:NuGet.Versioning.IVersionComparer">
      <summary>
            IVersionComparer represents a version comparer capable of sorting and determining the equality of
            SemanticVersion objects.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.IVersionRangeComparer">
      <summary>
            Version range comparer
            </summary>
    </member>
    <member name="T:NuGet.Versioning.NuGetVersion">
      <summary>
            A hybrid implementation of SemVer that supports semantic versioning as described at http://semver.org while
            not strictly enforcing it to
            allow older 4-digit versioning schemes to continue working.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.String)">
      <summary>
            Creates a NuGetVersion using NuGetVersion.Parse(string)
            </summary>
      <param name="version">Version string</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a NuGetVersion from an existing NuGetVersion
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Version,System.String,System.String)">
      <summary>
            Creates a NuGetVersion from a .NET Version
            </summary>
      <param name="version">Version numbers</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a NuGetVersion X.Y.Z
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha.1.2#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabels">Prerelease labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z-alpha#build01
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z-alpha.1#build01
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
      <param name="releaseLabels">Prerelease labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
      <summary>
            Creates a NuGetVersion from a .NET Version with additional release labels, build metadata, and a
            non-normalized version string.
            </summary>
      <param name="version">Version numbers</param>
      <param name="releaseLabels">prerelease labels</param>
      <param name="metadata">Build metadata</param>
      <param name="originalVersion">Non-normalized original version string</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.ToString">
      <summary>
            Returns the version string.
            </summary>
      <remarks>This method includes legacy behavior. Use ToNormalizedString() instead.</remarks>
      <remarks>Versions with SemVer 2.0.0 components are automatically normalized.</remarks>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.Parse(System.String)">
      <summary>
            Creates a NuGetVersion from a string representing the semantic version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.TryParse(System.String,NuGet.Versioning.NuGetVersion@)">
      <summary>
            Parses a version string using loose semantic versioning rules that allows 2-4 version components followed
            by an optional special version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.TryParseStrict(System.String,NuGet.Versioning.NuGetVersion@)">
      <summary>
            Parses a version string using strict SemVer rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.GetLegacyString(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a legacy version string using System.Version
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.Version">
      <summary>
            A System.Version representation of the version without metadata or release labels.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.IsLegacyVersion">
      <summary>
            True if the NuGetVersion is using legacy behavior.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.Revision">
      <summary>
            Revision version R (x.y.z.R)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.IsSemVer2">
      <summary>
            Returns true if version is a SemVer 2.0.0 version
            </summary>
    </member>
    <member name="T:NuGet.Versioning.NuGetVersionFloatBehavior">
      <summary>
            Specifies the floating behavior type.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.None">
      <summary>
            Lowest version, no float
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Prerelease">
      <summary>
            Highest matching pre-release label
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Revision">
      <summary>
            x.y.z.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Patch">
      <summary>
            x.y.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Minor">
      <summary>
            x.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Major">
      <summary>
            *
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.AbsoluteLatest">
      <summary>
            Float major and pre-release
            </summary>
    </member>
    <member name="T:NuGet.Versioning.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Value cannot be null or an empty string..
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Invalidvalue">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid version string..
            </summary>
    </member>
    <member name="T:NuGet.Versioning.SemanticVersion">
      <summary>
            A strict SemVer implementation
            </summary>
      <summary>
            A base version operations
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(NuGet.Versioning.SemanticVersion)">
      <summary>
            Creates a SemanticVersion from an existing SemanticVersion
            </summary>
      <param name="version">Version to clone.</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a SemanticVersion X.Y.Z
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha.1.2#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabels">Release labels that have been split by the dot separator</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Version,System.String,System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="version">Version</param>
      <param name="releaseLabel">Full release label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="revision">x.y.z.R</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="major">
      </param>
      <param name="minor">
      </param>
      <param name="patch">
      </param>
      <param name="revision">
      </param>
      <param name="releaseLabels">
      </param>
      <param name="metadata">
      </param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="version">Version</param>
      <param name="releaseLabels">Release labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToNormalizedString">
      <summary>
            Gives a normalized representation of the version.
            This string is unique to the identity of the version and does not contain metadata.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToFullString">
      <summary>
            Gives a full representation of the version include metadata.
            This string is not unique to the identity of the version. Other versions 
            that differ on metadata will have a different full string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToString">
      <summary>
            Get the normalized string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToString(System.String,System.IFormatProvider)">
      <summary>
            Custom string format.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.TryFormatter(System.String,System.IFormatProvider,System.String@)">
      <summary>
            Internal string formatter.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.GetHashCode">
      <summary>
            Hash code
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(System.Object)">
      <summary>
            Object compare.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(NuGet.Versioning.SemanticVersion)">
      <summary>
            Compare to another SemanticVersion.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(System.Object)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(NuGet.Versioning.SemanticVersion)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            True if the VersionBase objects are equal based on the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Compares NuGetVersion objects using the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_Equality(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_Inequality(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Not equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_LessThan(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Less than
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_LessThanOrEqual(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Less than or equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_GreaterThan(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Greater than
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_GreaterThanOrEqual(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Greater than or equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Parse(System.String)">
      <summary>
            Parses a SemVer string using strict SemVer rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.TryParse(System.String,NuGet.Versioning.SemanticVersion@)">
      <summary>
            Parse a version string
            </summary>
      <returns>false if the version is not a strict semver</returns>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ParseSections(System.String)">
      <summary>
            Parse the version string into version/release/build
            The goal of this code is to take the most direct and optimized path
            to parsing and validating a semver. Regex would be much cleaner, but
            due to the number of versions created in NuGet Regex is too slow.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Major">
      <summary>
            Major version X (X.y.z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Minor">
      <summary>
            Minor version Y (x.Y.z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Patch">
      <summary>
            Patch version Z (x.y.Z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.ReleaseLabels">
      <summary>
            A collection of pre-release labels attached to the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Release">
      <summary>
            The full pre-release label for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.IsPrerelease">
      <summary>
            True if pre-release labels exist for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.HasMetadata">
      <summary>
            True if metadata exists for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Metadata">
      <summary>
            Build metadata attached to the version.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionComparer">
      <summary>
            An IVersionComparer for NuGetVersion and NuGetVersion types.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.Default">
      <summary>
            A default comparer that compares metadata as strings.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.Version">
      <summary>
            A comparer that uses only the version numbers.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.VersionRelease">
      <summary>
            Compares versions without comparing the metadata.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.VersionReleaseMetadata">
      <summary>
            A version comparer that follows SemVer 2.0.0 rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.#ctor">
      <summary>
            Creates a VersionComparer using the default mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Creates a VersionComparer that respects the given comparison mode.
            </summary>
      <param name="versionComparison">comparison mode</param>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Equals(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Determines if both versions are equal.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Compare(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Compares the given versions using the VersionComparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.GetHashCode(NuGet.Versioning.SemanticVersion)">
      <summary>
            Gives a hash code based on the normalized version string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Compare(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Compare versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareLegacyVersion(NuGet.Versioning.NuGetVersion,NuGet.Versioning.NuGetVersion)">
      <summary>
            Compares the 4th digit of the version number.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareReleaseLabels(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Compares sets of release labels.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareRelease(System.String,System.String)">
      <summary>
            Release labels are compared as numbers if they are numeric, otherwise they will be compared
            as strings.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionComparison">
      <summary>
            Version comparison modes.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.Default">
      <summary>
            Semantic version 2.0.1-rc comparison with additional compares for extra NuGetVersion fields.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.Version">
      <summary>
            Compares only the version numbers.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.VersionRelease">
      <summary>
            Include Version number and Release labels in the compare.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.VersionReleaseMetadata">
      <summary>
            Include all metadata during the compare.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionExtensions">
      <summary>
            Version extension methods.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionExtensions.FindBestMatch``1(System.Collections.Generic.IEnumerable{``0},NuGet.Versioning.VersionRange,System.Func{``0,NuGet.Versioning.NuGetVersion})">
      <summary>
            Find the version that best matches the VersionRange and the floating behavior.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionExtensions.FindBestMatch(System.Collections.Generic.IEnumerable{NuGet.Versioning.INuGetVersionable},NuGet.Versioning.VersionRange)">
      <summary>
            Find the version that best matches the VersionRange and the floating behavior.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionFormatter">
      <summary>
            Custom formatter for NuGet versions.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionFormatter.Instance">
      <summary>
            A static instance of the VersionFormatter class.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Format a version string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetFormat(System.Type)">
      <summary>
            Get version format type.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetNormalizedString(NuGet.Versioning.SemanticVersion)">
      <summary>
            Create a normalized version string. This string is unique for each version 'identity' 
            and does not include leading zeros or metadata.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetFullString(NuGet.Versioning.SemanticVersion)">
      <summary>
            Create the full version string including metadata. This is primarily for display purposes.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRange">
      <summary>
            Represents a range of versions and a preferred order.
            </summary>
      <summary>
            Static factory methods for creating version range objects.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.All">
      <summary>
            A range that accepts all versions, prerelease and stable.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllFloating">
      <summary>
            A range that accepts all versions, prerelease and stable, and floats to the highest.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllStable">
      <summary>
            A range that accepts all stable versions
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllStableFloating">
      <summary>
            A range that accepts all versions, prerelease and stable, and floats to the highest.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.None">
      <summary>
            A range that rejects all versions
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a range that is greater than or equal to the minVersion.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion,NuGet.Versioning.FloatRange)">
      <summary>
            Creates a range that is greater than or equal to the minVersion with the given float behavior.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="floatRange">Floating behavior.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.VersionRange,NuGet.Versioning.FloatRange)">
      <summary>
            Clones a version range and applies a new float range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.FloatRange,System.String)">
      <summary>
            Creates a VersionRange with the given min and max.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="includeMinVersion">True if minVersion satisfies the condition.</param>
      <param name="maxVersion">Upper bound of the version range.</param>
      <param name="includeMaxVersion">True if maxVersion satisfies the condition.</param>
      <param name="floatRange">The floating range subset used to find the best version match.</param>
      <param name="originalString">The original string being parsed to this object.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToString">
      <summary>
            Normalized range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToNormalizedString">
      <summary>
            Normalized range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToLegacyString">
      <summary>
            A legacy version range compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToLegacyShortString">
      <summary>
            A short legacy version range compatible with NuGet 2.8.3.
            Ex: 1.0.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToString(System.String,System.IFormatProvider)">
      <summary>
            Format the version range with an IFormatProvider
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryFormatter(System.String,System.IFormatProvider,System.String@)">
      <summary>
            Format the range
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.PrettyPrint">
      <summary>
            Format the version range in Pretty Print format.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.FindBestMatch(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion})">
      <summary>
            Return the version that best matches the range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.IsBetter(NuGet.Versioning.NuGetVersion,NuGet.Versioning.NuGetVersion)">
      <summary>
            Determines if a given version is better suited to the range than a current version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToNonSnapshotRange">
      <summary>
            Removes the floating snapshot part of the minimum version if it exists.
            Ex: 1.0.0-* -&gt; 1.0.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.GetNonSnapshotVersion(NuGet.Versioning.NuGetVersion)">
      <summary>
            Remove the snapshot version section of a version
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToShortString">
      <summary>
            ToLegacyShortString that also includes floating ranges
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Parse(System.String)">
      <summary>
            The version string is either a simple version or an arithmetic range
            e.g.
            1.0         --&gt; 1.0 ≤ x
            (,1.0]      --&gt; x ≤ 1.0
            (,1.0)      --&gt; x &lt; 1.0
            [1.0]       --&gt; x == 1.0
            (1.0,)      --&gt; 1.0 &lt; x
            (1.0, 2.0)   --&gt; 1.0 &lt; x &lt; 2.0
            [1.0, 2.0]   --&gt; 1.0 ≤ x ≤ 2.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Parse(System.String,System.Boolean)">
      <summary>
            Direct parse
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryParse(System.String,NuGet.Versioning.VersionRange@)">
      <summary>
            Parses a VersionRange from its string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryParse(System.String,System.Boolean,NuGet.Versioning.VersionRange@)">
      <summary>
            Parses a VersionRange from its string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion})">
      <summary>
            Returns the smallest range that includes all given versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the smallest range that includes all given versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange})">
      <summary>
            Returns the smallest range that includes all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the smallest range that includes all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.CommonSubSet(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange})">
      <summary>
            Returns the greatest common range that satisfies all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.CommonSubSet(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the greatest common range that satisfies all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.HasValidRange(NuGet.Versioning.VersionRange)">
      <summary>
            Verify the range has an actual width.
            Ex: no version can satisfy (3.0.0, 3.0.0)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.IsFloating">
      <summary>
            True if the range has a floating version above the min version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.Float">
      <summary>
            Optional floating range used to determine the best version match.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.OriginalString">
      <summary>
            Original string being parsed to this object.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeBase">
      <summary>
            A base version range that handles ranges only and not any of the preferred version logic.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.#ctor(NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.NuGetVersion,System.Boolean)">
      <summary>
            Creates a VersionRange with the given min and max.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="includeMinVersion">True if minVersion satisfies the condition.</param>
      <param name="maxVersion">Upper bound of the version range.</param>
      <param name="includeMaxVersion">True if maxVersion satisfies the condition.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion)">
      <summary>
            Determines if an NuGetVersion meets the requirements.
            </summary>
      <param name="version">SemVer to compare</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Determines if an NuGetVersion meets the requirements using the given mode.
            </summary>
      <param name="version">SemVer to compare</param>
      <param name="versionComparison">VersionComparison mode used to determine the version range.</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion,NuGet.Versioning.IVersionComparer)">
      <summary>
            Determines if an NuGetVersion meets the requirements using the version comparer.
            </summary>
      <param name="version">SemVer to compare.</param>
      <param name="comparer">Version comparer used to determine if the version criteria is met.</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(System.Object)">
      <summary>
            Compares the object as a VersionRange with the default comparer
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.GetHashCode">
      <summary>
            Returns the hash code using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Default compare
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionRangeComparer)">
      <summary>
            Use the VersionRangeComparer for equality checks
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.VersionComparison)">
      <summary>
            Use a specific VersionComparison for comparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionComparer)">
      <summary>
            Use a specific IVersionComparer for comparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.IsSubSetOrEqualTo(NuGet.Versioning.VersionRangeBase)">
      <summary>
            SubSet check
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.IsSubSetOrEqualTo(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionComparer)">
      <summary>
            SubSet check
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasLowerBound">
      <summary>
            True if MinVersion exists;
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasUpperBound">
      <summary>
            True if MaxVersion exists.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasLowerAndUpperBounds">
      <summary>
            True if both MinVersion and MaxVersion exist.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.IsMinInclusive">
      <summary>
            True if MinVersion exists and is included in the range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.IsMaxInclusive">
      <summary>
            True if MaxVersion exists and is included in the range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.MaxVersion">
      <summary>
            Maximum version allowed by this range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.MinVersion">
      <summary>
            Minimum version allowed by this range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasPrereleaseBounds">
      <summary>
            Infer if the range should allow prerelease versions based on if the lower or upper bounds 
            contain prerelease labels.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeComparer">
      <summary>
            A version range comparer capable of using different VersionComparers to check if ranges are equivalent.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor">
      <summary>
            Default version range comparer.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Compare versions with a specific VersionComparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor(NuGet.Versioning.IVersionComparer)">
      <summary>
            Compare versions with a specific IVersionComparer
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.VersionRangeBase)">
      <summary>
            Checks if two version ranges are equivalent. This follows the rules of the version comparer
            when checking the bounds.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.GetHashCode(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a hash code based on all properties of the range. This follows the rules of the
            version comparer when comparing the version bounds.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeComparer.Default">
      <summary>
            Default Version comparer
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeComparer.VersionRelease">
      <summary>
            Compare versions using the Version and Release
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeFormatter">
      <summary>
            VersionRange formatter
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.#ctor">
      <summary>
            Custom version range format provider.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Format a version range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetFormat(System.Type)">
      <summary>
            Format type.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetNormalizedString(NuGet.Versioning.VersionRange)">
      <summary>
            Builds a normalized string with no short hand
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetToString(NuGet.Versioning.VersionRange)">
      <summary>
            Builds a string to represent the VersionRange. This string can include short hand notations.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetLegacyShortString(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a legacy short string that is compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetLegacyString(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a legacy string that is compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.PrettyPrint(NuGet.Versioning.VersionRange)">
      <summary>
            A pretty print representation of the VersionRange.
            </summary>
    </member>
  </members>
</doc>